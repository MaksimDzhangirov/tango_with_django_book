.. _model-label:

Модели и базы данных
====================
При работе с базой данных часто необходимо использовать SQL. Django берет большую часть этой работы на себя, используя функции *объектно-реляционного отображения (ORM)* и инкапсулируя таблицы базы данных с помощью моделей. По сути, модель - это Python объект, который описывает Вашу модель данных/таблицу. Вместо того чтобы непосредственно работать с таблицей базы данных через SQL, Вы изменяете соответствующий Python объект. В этой главе мы шаг за шагом рассмотрим, как настроить базу данных и модели, требуемые для Rango.

Требования приложения Rango
---------------------------
Сначала давайте рассмотрим требования к данным для Rango. Ниже приведены основные сведения, касающиеся требованиям к данным для Rango.

* Rango является по сути *каталогом с веб страницами* - сайтом, содержащим ссылки на другие веб сайты.
* Существует множество различных *категорий с веб страницами* и каждая категория сожержит множество ссылок. Мы предположили в Главе :ref:`overview-label`, что это связь один-ко-многим.  Смотри диаграмму сущность-связь ниже.
* Категория имеет название, число посещений и количество лайков.
* Страница ссылается на категорию, имеет заголовок, URL и число просмотров.

.. figure:: ../images/rango-erd.svg
	:scale: 100%
	:figclass: align-center

	Диаграмма сущность-связь для двух основных сущностей Rango.

Сообщаем Django о Вашей базе данных
-----------------------------------
Прежде чем мы сможем создать какие-либо модели, необходимо настроить базу данных. В Django 1.7, когда Вы создаете проект, Django автоматически заполняет словарь под названием ``DATABASES``, который расположен в Вашем файле ``settings.py``. Он будет содержать примерно следующее:

.. code-block:: python
	
	DATABASES = {
	    'default': {
	        'ENGINE': 'django.db.backends.sqlite3',
	        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
	    }
	}


	
Как видно в качестве СУБД по умолчанию выбирается бэкенд базы данных SQLite3. Это дает нам доступ к упрощенной Python базе данных `SQLite <http://www.sqlite.org/>`_, которую удобно использовать для разработки.
Единственное второе значение, которое нужно настроить - это ``NAME`` - пара ключ/значение, которой мы присвоили значение os.path.join(BASE_DIR, 'db.sqlite3'). Можно также ввести переменную ``DATABASE_PATH`` выше этого словаря и присвоить os.path.join(BASE_DIR, 'db.sqlite3') ей. Тогда в качестве значения для ключа ``NAME`` нужно указать ``DATABASE_PATH``. Для иных СУБД в словарь могут также добавляться другие ключи, например, ``USER``, ``PASSWORD``, ``HOST`` и ``PORT``.

.. note:: Хотя для целей этого учебного пособия достаточно использовать СУБД SQLite, это не лучшее решение при развертывании Вашего приложения. Вместо этого лучше использовать более надежную и масштабируемую СУБД. Django поддерживает несколько других популярных СУБД, таких как `PostgreSQL <http://www.postgresql.org/>`_ и `MySQL <http://www.mysql.com/>`_. Чтобы узнать больше, смотри `официальную Django документацию по настройке СУБД <https://docs.djangoproject.com/en/1.7/ref/settings/#std:setting-DATABASE-ENGINE>`_. Вы можете также просмотреть `эту прекрасную статью <http://www.sqlite.org/whentouse.html>`_ на сайте SQLite, в которой поясняется когда стоит, а когда нет использовать упрощенную СУБД 
SQLite.

Создание моделей
----------------
После настройки Вашей базы данных в ``settings.py``, давайте создадим две начальных модели данных для приложения Rango.

В ``rango/models.py``, мы определим два класса - оба должны наследоваться от ``django.db.models.Model``. Два Python класса будут определениями для моделей, представляющих *категории* и *страницы*. Определим модели ``Category`` (Категория) и ``Page`` (Страница) следующим образом.

.. code-block:: python
	
	class Category(models.Model):
	    name = models.CharField(max_length=128, unique=True)

	    def __unicode__(self):  # Используйте __unicode в Python 2 и __str__ в Python 3
	        return self.name
	
	class Page(models.Model):
	    category = models.ForeignKey(Category)
	    title = models.CharField(max_length=128)
	    url = models.URLField()
	    views = models.IntegerField(default=0)
	    
	    def __unicode__(self):	# Используйте __unicode в Python 2 и __str__ в Python 3
	        return self.title

При определении модели Вам нужно указать список атрибутов и связанные с ними типы, а также любые дополнительные необязательные параметры. Django предоставляет множество встроенных полей. Наиболее часто используемые перечислены ниже.

* ``CharField`` - поле для хранения символьных данных (например, строк). Параметр ``max_length`` определяет максимальное число символов, которое можно сохранить в поле.
* ``URLField`` - во многом похоже на ``CharField``, но создано для хранения URL ресурсов. Вы также можете определеить для него параметр ``max_length``.
* ``IntegerField`` - хранит целые числа.
* ``DateField``, хранит Python объект ``datetime.date``.

Просмотрите `Django документацию по полям моделей <https://docs.djangoproject.com/en/1.7/ref/models/fields/>`_ для получения полного списка.

Для каждого поля Вы можете указать атрибут ``unique``. Если присвоить ему значение ``True``, то значение поля не может повторяться для этой модели в базе данных. Например, взгляните на нашу модель ``Category``, определенную выше. Поле ``name`` имеет атрибут ``unique`` равный ``True`` - таким образом, каждое название категории должно быть уникальным.

Это полезно, если Вы хотите использовать определенное поле в качестве дополнительного ключа базы данных. Вы также можете определить дополнительные атрибуты для каждого поля, например, указать значение по умолчанию (``default='value'``) и может ли значение поля быть ``NULL`` (``null=True``)  или нет.

Django также предоставляет простые механизмы, которые позволяют связать модели/таблицы базы данных. Эти механизмы инкапсулированы в три следующих типа поля и перечислены ниже.

* ``ForeignKey`` - тип поля, которое позволяет нам создавать связь один-ко-многим.
* ``OneToOneField`` - тип поля, которое позволяет нам определять строгую связь один-к-одному.
* ``ManyToManyField`` - тип поля, которое позволяет нам определить связь много-ко-многим.

Из нашего вышеприведенного примера для моделей, поле ``category`` в модели ``Page`` имеет тип ``ForeignKey``. Это позволяет нам создать связь один-ко-многим с моделью/таблицей ``Category``, которая указана в качестве аргумента конструктору поля. *Вы должны знать, что Django создает поле ID автоматически в каждой таблице, связанной с моделью. Таким образом, Вам не нужно явно определять первичный ключ для каждой модели - это сделано за Вас!*

.. note:: При создании Django модели хорошей практикой считается добавление метода ``__unicode__()`` - метода почти идентичного методу ``__str__()``. Если Вам не знакомы эти методы, то считайте, что они аналогичны методу ``toString()`` в Java классе. Метод ``__unicode__()`` таким образом используется для получения Юникод представления экземпляра модели. Например, Наша модель ``Category`` возвращает название категории в методе ``__unicode__()`` - что очень удобно, когда Вы начнете использовать интерфейс администратора Django позднее в этой главе.
	Добавление метода ``__unicode__()`` в Ваши классы также полезно при отладке Вашего кода. Вызов команды ``print`` для экземпляра модели ``Category`` *без* метода ``__unicode__()`` возвратит ``<Category: Category object>``. Мы знаем, что это категория, но *какая*? Добавление ``__unicode__()`` вернет ``<Category: python>``, где ``python`` - это ``название`` данной категории. Так намного лучше!
	

Создание и миграция базы данных
-------------------------------
После того как определены наши модели, мы можем с помощью Django создать их табличные представления в нашей базе данных. В предыдущих версиях Django это выполнялось бы с помощью команды:

``$ python manage.py syncdb``

Однако в Django 1.7 существует инструмент миграции для настройки и обновления базы данных, позволяющий отражать изменения в моделях. Из-за этого процесс стал немного более сложным - но смысл в том, что Вы можете изменять модели и обновлять базу данных без необходимости удалять таблицы.

Настройка базы данных и создание суперпользователя
....................................
Если Вы не сделали этого раньше, то сначала Вам необходимо инициализировать базу данных. Это осуществляется с помощью команды ``migrate``.


::


	$ python manage.py migrate


	Operations to perform:
	  Apply all migrations: admin, contenttypes, auth, sessions
	Running migrations:
	  Applying contenttypes.0001_initial... OK
	  Applying auth.0001_initial... OK
	  Applying admin.0001_initial... OK
	  Applying sessions.0001_initial... OK
	  

Если Вы помните в ``settings.py`` был список INSTALLED_APPS и этот первый вызов команды ``migrate``, создает таблицы для соответствующих приложений, т. е., auth, admin и т. д.. Должен создаться файл под названием ``db.sqlite`` в основном каталоге Вашего проекта.

Теперь нужно создать суперпользователя для управления базой данных. Выполните следующую команду.

::


	$ python manage.py createsuperuser

Учетная запись суперпользователя будет использоваться для доступа к интерфейсу администратора Django позже в этом учебном пособии. Введите имя пользователя для учетной записи, адрес e-mail и пароль. После этого скрипт должен успешно завершиться. Запомните или запишите имя пользователя и пароль для Вашей учетной записи суперпользователя.

Создание / обновление моделей/таблиц
....................................
Всякий раз, когда Вы вносите изменения в модели, Вы должны зафиксировать изменения с помощью команды ``makemigrations`` для конкретного приложения. Поэтому для *rango*, нужно выполнить:

::
	
	$ python manage.py makemigrations rango
	
	Migrations for 'rango':
	  0001_initial.py:
	    - Create model Category
	    - Create model Page

Если Вы просмотрите каталог ``rango/migrations``, то увидите, что был создан Python скрипт ``0001_initial.py''. Чтобы увидеть SQL команды, которые будут выполняться для осуществления этой миграции, вызовите команду ``python manage.py sqlmigrate <название_приложения> <номер_миграции>``. Номер миграции, показанной выше - 0001, поэтому мы выполним команду ``python manage.py sqlmigrate rango 0001`` для приложения *rango*, чтобы увидеть SQL команды. Попробуйте сделать это.

Теперь, чтобы применить эти миграции (которые по существу создадут таблицы в базе данных), выполните команду:

::
	
	
	$ python manage.py migrate

	Operations to perform:
	  Apply all migrations: admin, rango, contenttypes, auth, sessions
	Running migrations:
	  Applying rango.0001_initial... OK
	  
	  
	  
.. warning:: Каждый раз, когда вы что-то изменяете в существующих моделях, *Вы должны повторять этот процесс*, выполняя команду ``python manage.py makemigrations <название_приложения>`` и затем ``python manage.py migrate``.

Возможно Вы также заметили, что в нашей модели ``Category`` в настоящий момент не хватает некоторых полей, которые были определены в ТЗ для приложения Rango. Мы добавим их позже, чтобы напомнить Вам о процессе обновления.


Django модели и командная оболочка Django
-----------------------------------------
Прежде чем перейти к демонстрации интерфейса администратора Django, стоит отметить, что Вы можете взаимодействовать с Django моделями из командной оболочки - очень полезный инструмент для целей отладки. Мы покажем, как создать экземпляр ``Category``, используя этот метод.

Чтобы получить доступ к командной оболочке необходимо опять вызвать ``manage.py`` из корневого каталога Вашего Django проекта. Выполните следующую команду.

``$ python manage.py shell``

Она запустит экземпляр интерпретатора Python и загрузит в него настройки Вашего проекта. После этого Вы можете взаимодействовать с моделями. Следующая сессия терминала демонстрирует эту функциональную возможность. Чтобы узнать, что делает каждая команда, прочитайте встроенные комментарии.

.. code-block:: python
	
	# Импортируем модель Category из приложения Rango
	>>> from rango.models import Category
	
	# Показать все текущие категории
	>>> print Category.objects.all()
	[] # Возвращает пустой список (пока не было определено ни одной категории!)
	
	# Создаем объект новой категории и сохраняем его в базу данных.
	>>> c = Category(name="Test")
	>>> c.save()
	
	# Теперь опять выведем список всех сохраненных объектов категорий
	>>> print Category.objects.all()
	[<Category: test>] # Теперь в базе данных сохранена категория под названием 'test'!
	
	# Выходим из командной оболочки Django.
	>>> quit()

В примере мы сначала импортируем модель, с которой мы хотим работать. Затем мы выводим на экран все существующие категории, которых нет, поскольку наша таблица пуста. Затем мы создаем и сохраняем категорию и опять выводим на экран все категории. Этот второй ``print`` должен показать только что созданную категорию.

.. note:: Вышеприведенный пример очень простой образец тех действий над базой данных, которые Вы можете осуществлять в командной оболочке Django. Если Вы ещё этого не сделали, пора полностью прочитать первую часть `официального учебного пособия по Django, чтобы узнать больше о взаимодействии с моделями <https://docs.djangoproject.com/en/1.7/intro/tutorial01/>`_. Также просмотрите `официальную Django документацию по списку доступных команд <https://docs.djangoproject.com/en/1.7/ref/django-admin/#available-commands>`_ при работе с моделями.

.. _admin-section:

Настраиваем интерфейс администратора
------------------------------------
Одна из выгодных особенностей Django заключается в наличии встроенного, веб интерфейса администратора, который позволяет нам просматривать и редактировать данные, хранящиеся в наших моделях и соответствующих таблицах базы данных. В файле ``settings.py`` видно, что одним из предустановленных приложений является ``django.contrib.admin`` и в файле ``urls.py`` Вашего проекта есть соответствующий ему URL шаблон - ``admin/``.

Запустите сервер для разработки:

::


	$ python manage.py runserver
	
	
и посетите URL, ``http://127.0.0.1:8000/admin/``. Используя имя и пароль, созданные для суперпользователя, войдите в интерфейс администратора Django. Интерфейс администратора содержит только таблицы, связанные с администрированием сайтов - ``Groups`` и ``Users``. Таким образом, нам необходимо указать Django, чтобы он также добавил модели из ``rango``.

Для этого откройте файл ``rango/admin.py`` и добавьте следующий код:


.. code-block:: python
	
	from django.contrib import admin
	from rango.models import Category, Page

	admin.site.register(Category)
	admin.site.register(Page)

Этот код *зарегистрирует* модели в интерфейсе администратора. Если бы существовала ещё одна модель, то необходимо было бы вызвать функцию ``admin.site.register()`` третий раз и передать модель в качестве параметра. (Примечание переводчика - конечно перед этим её надо импортировать как это сделано для приложения *rango*).

После всех этих изменений, опять посетите/обновите ``http://127.0.0.1:8000/admin/``. Теперь должны быть видны модели ``Category`` м ``Page``, как на Рисунке :num:`fig-rango-admin`. 

.. _fig-rango-admin:

.. figure:: ../images/ch5-rango-admin-models.png
	:figclass: align-center

	Интерфейс администратора Django. Обратите внимание на раздел Rango и две модели внутри неё.

Попробуйте нажать на ссылку ``Categorys`` в разделе ``Rango``. Там Вы должны увидеть категорию ``test``, которую мы создали через командную оболочку Django. Попробуйте удалить категорию, поскольку позже мы заполним базу данных с помощью скрипта. Интерфейс прост в использовании. Потратьте несколько минут на создание, изменение и удаление категорий и страниц. Вы также можете добавлять новых пользователей, которые могут войти в интерфейс администратора из Вашего проекта. Для этого добавьте пользователя в таблицу ``User`` приложения ``Auth``. 

.. note:: Обратите внимание на ошибку в интерфейсе администратора (categorys, а не categories). Эта проблема может быть решена добавляя вложенный класс ``Meta`` в Ваши определения моделей с помощью атрибута ``verbose_name_plural``. Чтобы узнать больше, просмотрите `официальную Django документацию по моделям <https://docs.djangoproject.com/en/1.7/topics/db/models/#meta-options>`_.

.. note:: Пример файла ``admin.py`` для нашего приложения Rango - это самый простой, рабочий пример из возможных. Существует множество различных особенностей, которые Вы можете использовать в ``admin.py``, для выполнения различных полезных настроек, таких как изменение способа отображения моделей в интерфейсе администратора. Для этого учебного пособия мы будем использовать минималистичный интерфейс администратора, но Вы можете просмотреть `официальную Django документацию по интерфейсу администратора <https://docs.djangoproject.com/en/1.7/ref/contrib/admin/>`_, чтобы узнать больше, если Вас это заинтересовало.

.. _model-population-script-label:

Создание скрипта для заполнения базы данных
-------------------------------------------
Ввод тестовых данных в базу данных как правило утомительное занятие. Многие разработчики добавляют некоторые фиктивные тестовые данных, случайно нажимая на клавиши, подобно обезьянам пытающимся набрать одну из пьес Шекспира. Если Вы член небольшой команды разработчиков, 
то каждый должен ввести некоторые данные. Вместо этого лучше написать скрипт так, чтобы каждый разработчик имел схожие данные и так, чтобы у всех были полезные и подходящие по смыслу данные, а не просто ничего не значащие тестовые данные. Таким образом, хорошей практикой является создание того, что мы называем *скритпом для заполнения* Вашей базы данных. Этот скрипт создан для автоматического заполнения Вашей базы данных тестовыми данными вместо Вас.

Чтобы создать скрипт для заполнения базы данных Rango, мы начнем с создания нового модуля Python в корневом каталоге нашего Django проекта (например, ``<рабочее пространство>/tango_with_django_project/``). Создадим файл ``populate_rango.py`` и добавим в него следующий код.

.. code-block:: python
	
	import os
	os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tango_with_django_project.settings')

	import django
	django.setup()

	from rango.models import Category, Page
	
	
	def populate():
	    python_cat = add_cat('Python')
	
	    add_page(cat=python_cat,
	        title="Official Python Tutorial",
	        url="http://docs.python.org/2/tutorial/")
	
	    add_page(cat=python_cat,
	        title="How to Think like a Computer Scientist",
	        url="http://www.greenteapress.com/thinkpython/")
	
	    add_page(cat=python_cat,
	        title="Learn Python in 10 Minutes",
	        url="http://www.korokithakis.net/tutorials/python/")
	
	    django_cat = add_cat("Django")
	
	    add_page(cat=django_cat,
	        title="Official Django Tutorial",
	        url="https://docs.djangoproject.com/en/1.5/intro/tutorial01/")
	
	    add_page(cat=django_cat,
	        title="Django Rocks",
	        url="http://www.djangorocks.com/")
	    
	    add_page(cat=django_cat,
	        title="How to Tango with Django",
	        url="http://www.tangowithdjango.com/")
	
	    frame_cat = add_cat("Other Frameworks")
	
	    add_page(cat=frame_cat,
	        title="Bottle",
	        url="http://bottlepy.org/docs/dev/")
	
	    add_page(cat=frame_cat,
	        title="Flask",
	        url="http://flask.pocoo.org")
	
	    # Выводим на экран пользователю то, что мы добавили в базу
	    for c in Category.objects.all():
	        for p in Page.objects.filter(category=c):
	            print "- {0} - {1}".format(str(c), str(p))
	
	def add_page(cat, title, url, views=0):
	    p = Page.objects.get_or_create(category=cat, title=title)[0]
	    p.url=url
	    p.views=views
	    p.save()
	    return p
	
	def add_cat(name):
	    c = Category.objects.get_or_create(name=name)[0]
	    return c
	
	# Код начинает выполняться отсюда!
	if __name__ == '__main__':
	    print "Starting Rango population script..."
	    populate()

Хотя мы ввели много кода, он выполняет относительно простые действия. Поскольку в начале файла мы определяем набор функций, выполнение кода начинается ближе к концу файла - на строке ``if __name__ == '__main__'``. Затем вызывается функция ``populate()``.

.. warning:: При импортировании Django моделей, убедитесь, что Вы импортировали настройки Вашего проекта и настроили переменную окружения ``DJANGO_SETTINGS_MODULE``, присвоив её значение файла настройки проекта. Затем Вы можете вызвать ``django.setup()``, чтобы импортировать настройки Django. Если не сделать этого, возникнет исключение. Из-за этого мы импортируем ``Category`` и ``Page`` после того как загружены настройки.

Функция ``populate()`` отвечает за вызов функций ``add_cat()`` и ``add_page()``, которые в свою очередь отвечают за создание новых категорий и страниц соответственно. ``populate()`` создает ссылки на категории каждый раз, когда мы создаем новый экземпляр модели ``Page`` и сохраняет их в нашей базе данных. Наконец, мы осуществляет обход в цикле наших моделей ``Category`` и ``Page``, чтобы вывести пользователю все экземпляры ``Page`` и соответствующие им категории.

.. note:: Для удобства при создании экземпляров модели мы используем метод ``get_or_create()``. Поскольку мы не хотим создавать копии одной и той же записи, мы используем ``get_or_create()``, чтобы проверить существует ли запись в базе данных. Если не существует, то метод создаёт её. Это позволяет не вводить много повторяющегося кода - вместо того, чтобы писать самим эту проверку - мы используем функцию, которая делает то же самое. Как говорилось выше, зачем изобретать велосипед?

	Метод ``get_or_create()`` возвращает кортеж ``(object, created)``. Первый элемент ``object`` - это ссылка на экземпляр модели, которую метод ``get_or_create()`` создает, если в базе данных не была найдена запись. Запись создается, используя параметры, которые Вы передали в метод - ``category``, ``title``, ``url`` и ``views`` как в вышеприведенном примере. Если запись уже существует в базе данных метод просто возвращает экземпляр модели, соответствующий записи. ``created`` - это логическое значение. ``true`` возвращается, если ``get_or_create()`` пришлось создать экземпляр модели.

	``[0]`` на конце нашего вызова метода извлекает ``object`` из кортежа, который возвращает ``get_or_create()``. Как и большинство  структур данных в других языках программирования, кортежи Python используют `нумерацию, начинающуюся с нуля <http://en.wikipedia.org/wiki/Zero-based_numbering>`_.

	Вы можете просмотреть `официальную Django документацию  <https://docs.djangoproject.com/en/1.7/ref/models/querysets/#get-or-create>`_, чтобы получить больше информации об удобном методе ``get_or_create()``.

После сохранения файла, мы можем запустить скрипт, изменив текущий рабочий каталог в терминале на корневой каталог Django проекта и выполняя модуль с помощью команды ``$ python populate_rango.py``. Вы должны увидеть на экране текст, подобный тому, который показан ниже.

::
	
	$ python populate_rango.py
	
	Starting Rango population script...
	- Python - Official Python Tutorial
	- Python - How to Think like a Computer Scientist
	- Python - Learn Python in 10 Minutes
	- Django - Official Django Tutorial
	- Django - Django Rocks
	- Django - How to Tango with Django
	- Other Frameworks - Bottle
	- Other Frameworks - Flask

Теперь давайте убедимся, что скрипт заполнил базу данных. Перезапустите Django сервер для разработки, перейдите к интерфейсу администратора и проверьте, что появились новые категории и страницы. Видите ли Вы все страницы, которые изображены на Рисунке :num:`fig-admin-populated`, если щелкните на ``Pages``?

.. _fig-admin-populated:

.. figure:: ../images/ch5-rango-admin.png
	:figclass: align-center

	Интерфейс администратора Django, показывающий таблицу Page, заполненную простыми данными из нашего скрипта.

Скрипту для заполнения требуется определенное время для записи, но когда Вы работаете в команде, Вы можете поделиться скриптом, поэтому каждый сможет создать базу данных и заполнить её. Также он пригодится для модульного тестирования.

Основные последовательности действий
------------------------------------
Теперь, когда мы рассмотрели основные принципы работы с моделями Django, пора подытожить процессы, необходимые для их настройки. Мы разобьем основные задачи на отдельные части.

Настройка Вашей базы данных
...........................
Для нового Django проекта, Вы должны сначала сообщить Django о базе данных, которую Вы собираетесь использовать (т. е., настроить ``DATABASES`` в settings.py). Вы можете также зарегистрировать любые модели в файле ``admin.py``, чтобы они были доступны через интерфейс администратора.

Добавление модели
.................
Последовательность действий для добавления модели может быть разбита на пять этапов.

#. Во-первых, создайте новую модель(и) в файле ``models.py`` Вашего Django приложения.
#. Отредактируйте ``admin.py``, чтобы добавить и зарегистрировать новую модель(и).
#. Затем выполните миграцию ``$ python manage.py makemigrations``.
#. Подтвердите изменения ``$ python manage.py migrate``. Эта команда создаст необходимую инфраструктуру в базе данных для новой модели(ей).
#. Создайте/отредактируйте скрипт для заполнения для новой модели(ей).

Неизбежно возникнет момент, когда Вам придется удалить базу данных. После этого Вам нужно будет запустить команду ``migrate``, затем команду ``createsuperuser``, после чего команды ``sqlmigrate`` для каждого приложения, наконец, Вы сможете заполнить базу данных.

Упражнения
----------
Теперь, когда Вы прочитали главу, попытайтесь выполнить следующие упражнения, чтобы закрепить на практике то, что Вы узнали.

* Измените модель Category так, чтобы она включала дополнительные атрибуты: ``views`` и ``likes`` - у которых значение по умолчанию равно нулю.
* Осуществите миграции для Вашего приложения/модели, затем выполните команду ``migrate`` для базы данных.
* Отредактируйте скрипт для заполнения так, чтобы категория *Python* имела 128 просмотров и 64 лайка, категория *Django* - 64 просмотра и 32 лайка и категория *Other Frameworks* - 32 просмотра и 16 лайков.
* Прочтите `вторую часть официального учебного пособия по Django <https://docs.djangoproject.com/en/1.7/intro/tutorial02/>`_, если Вы ещё этого не сделали. Это ещё больше закрепит знания, которые Вы получили здесь. Также Вы больше узнаете о настройке интерфейса администратора.
* Измените интерфейс администратора так, чтобы когда Вы просматривали модель Page, она отображала в виде списка название страницы, категорию, в которой она находится и URL.

Подсказки к упражнениям
.......................
Если Вам необходима помощью или стимул для выполнения этих упражнений, то мы надеемся, что эти подсказки помогут Вам.

* Измените модель ``Category``, добавив поля ``view`` и ``likes`` как ``IntegerFields``.
* Измените функцию ``add_cat`` в скрипте ``populate.py``, чтобы учесть ``views`` и ``likes``. Когда Вы получите Category c, Вы можете изменить число просмотров, обращаясь к ``c.views``. Подобным образом измените количество лайков.
* Чтобы изменить интерфейс администратора, необходимо отредактировать ``rango/admin.py`` и создать класс ``PageAdmin``, который наследуется от ``admin.ModelAdmin``.
* В Ваш новый класс ``PageAdmin`` добавьте ``list_display = ('title', 'category', 'url')``.
* Наконец, зарегистрируйте класс ``PageAdmin`` в интерфейсе администратора Django. Вы должны отредактировать строку ``admin.site.register(Page)``. Измените её на ``admin.site.register(Page, PageAdmin)`` в файле ``admin.py`` приложения Rango.

.. _fig-admin-customised:

.. figure:: ../images/ch5-rango-admin-custom.png
	:figclass: align-center
	
	Обновленный вид страницы интерфейса администратора для модели Page с добавленными столбцами для категории и URL.


