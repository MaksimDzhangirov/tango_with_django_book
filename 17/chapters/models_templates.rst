.. _model-using-label:

Модели, шаблоны и представления
===============================
Теперь, когда мы настроили модели и заполнили их данными, можно объединить наши знания полученные ранее. Мы выясним, как получить доступ к данным моделей из представлений и как показать эти данные с помощью шаблонов.

Основная последовательность действий: Создание страниц с изменяемыми данными
----------------------------------------------------------------------------
Чтобы создать страницу с изменяемыми данными в Django, необходимо выполнить последовательность действий из пяти основных этапов.

#. Во-первых, импортировать модели, которые Вы хотите использовать, в файле ``views.py`` Вашего приложения.
#. В представлении, которое Вы хотите использовать, запросите модель, чтобы получить данные, необходимые для отображения.
#. Передайте результаты из модели в контекст шаблона.
#. Настройте Ваш шаблон, чтобы отобразить данные пользователю в каком Вы хотите виде.
#. Если Вы ещё этого не сделали, сопоставьте URL Вашему представлению.

Эти этапы показывают, как в фреймворке Django проводятся границы между моделями, представлениями и шаблонами.

Показываем категории на главной странице Rango
----------------------------------------------
Одним из требований к главной странице было отображение первых пяти категорий по рангу.

Импорт требуемых моделей
........................
Для выполнения этого требования мы осуществим каждый из вышеприведенных этапов. Во-первых, откройте ``rango/views.py`` и импортируйте модуль ``Category`` из файла ``models.py`` Rango.

.. code-block:: python
	
	# Import the Category model
	from rango.models import Category

Изменяем представление Index
............................
Выполнив первый этап, затем мы изменяем нашу функцию ``index()``. Вспомним, что функция ``index()`` отвечает за представление главной страницы. Изменим функцию, чтобы она выглядела так, как показано ниже.

.. code-block:: python
	
	def index(request):
	    # Осуществляем запрос к базе данных для получения списках ВСЕХ категорий, хранящихся в ней на текущий момент.
	    # Упорядочиваем категории по количеству лайков в порядке убывания.
	    # Извлекаем только первые 5 - или все, если их число меньше 5.
	    # Помещаем список в наш словарь контекста, который будет передан механизму шаблонов.
	    category_list = Category.objects.order_by('-likes')[:5]
	    context_dict = {'categories': category_list}
	    
	    # Формируем ответ для клиента по шаблону и отправляем обратно!
	    return render(request, 'rango/index.html', context_dict)

Здесь мы сразу выполнили второй и третий этап. Во-первых, мы запросили модель ``Category`` для извлечения пяти первых категорий. Здесь мы использовали метод ``order_by()`` для сортировки по числу лайков в порядке убывания, поэтому был добавлен знак ``-``. Затем мы ограничили список первыми пятью объектами ``Category`` в списке.

После завершения запроса, мы передаем ссылку на список (сохраненный в виде переменной ``category_list``) в словарь, ``context_dict``. Этот словарь затем передается как часть контекста механизму шаблонов в вызове функции ``render()``.

.. warning:: Обратите внимание, что модель Category содержит поле ``likes``. Таким образом, для нормальной работы функции, Вы должны выполнить упражнения в предыдущей главе, т. е., модель Category должна быть отредактирована так, чтобы в ней было поле ``likes``. 


Изменение шаблона Index
.......................
После обновления представления все что осталось сделать - это обновить шаблон ``rango/index.html``, расположенный в каталоге ``templates`` Вашего проекта. Измените HTML код файла так как показано ниже в примере.

.. code-block:: html
	
	<!DOCTYPE html>
	<html>
	    <head>
	        <title>Rango</title>
	    </head>
	
	    <body>
	        <h1>Rango says...hello world!</h1>
	
	        {% if categories %}
	            <ul>
	                {% for category in categories %}
	                <li>{{ category.name }}</li>
	                {% endfor %}
	            </ul>
	        {% else %}
	            <strong>There are no categories present.</strong>
	        {% endif %}
	        
	        <a href="/rango/about/">About</a>
	    </body>
	</html>

Здесь мы использовали язык шаблона Django, чтобы отобразить данные, используя управляющие операторы ``if`` и ``for``. В ``<body>`` страницы мы проверяем содержит ли ``categories`` (имя переменной контекста, в которой находится наш список категорий) какие-либо категории (с помощью оператора ``{% if categories %}``).

Если да, то создаем неупорядоченный HTML список (внутри тега ``<ul>``). Цикл for (``{% for category in categories %}``) перебирает список, выводя каждое название категории ``({{ category.name }})``, внутри пары тегов ``<li>``.

Если категорий не существует, то выдается сообщение, указывающее на это.

Как видно из примера, в языке шаблона Django все команды заключены в теги ``{%`` и ``%}``, тогда как на переменные ссылаются с помощью скобок ``{{`` и ``}}``.

Если Вы теперь посетите домашнюю страницу Rango по адресу http://127.0.0.1:8000/rango/, Вы должны увидеть список из трех категорий ниже заголовка страницы, как показано на Рисунке :num:`fig-rango-categories-simple`.


.. _fig-rango-categories-simple:

.. figure:: ../images/rango-categories-simple.png
	:figclass: align-center

	Домашняя страница Rango - теперь генерирующаяся динамически - показывающая список категорий. Прекрасно!


Создание страницы с подробной информацией о категории
-----------------------------------------------------
В соответствии с ТЗ приложения Rango, также необходимо показывать список страниц, которые связаны с каждой категорией. При этом нам придется решить несколько проблем. Необходимо создать новое представление, которое должно принимать параметры. Мы также создадим URL шаблоны и URL строки для кодирования названий категорий.

URL настройка и сопоставление
.............................
Сначала решим задачу, связанную с URL. Одним из способов решения этой проблемы является использование уникального идентификатора (ID) для каждой категории в URL. Например, мы можем создать URLы вида ``/rango/category/1/`` или ``/rango/category/2/``, где числа соответствуют категориям с уникальными идентификаторами 1 и 2 соответственно. Однако эти URLы трудно понять человеку. Хотя можно было бы сделать вывод, что числа связаны с категориями, как пользователь поймет, с какой категорией связан уникальный идентификатор 1 или 2? Пользователь не узнает этого пока не перейдет по URL в строке браузера.

Вместо этого мы могли бы просто использовать название категории в качестве части URL. Переход по URL ``/rango/category/Python/`` должен выдавать список страниц, связанных с категорией Python. Это простой, читаемый и понятный URL. Если мы хотим использовать этот метод, то необходимо обрабатывать категории, которые будут состоять из нескольких слов, например, 'Other Frameworks' и т. д..

.. note:: Создание чистых URLов - это важный аспект веб проектирования. Смотри `статью на Википедии о чистых URLах <http://en.wikipedia.org/wiki/Clean_URL>`_, чтобы узнать больше.

Чтобы решить эту проблему мы будем использовать функцию slugify, предоставляемую Django, используя ответы, данные в http://stackoverflow.com/questions/837828/how-do-i-create-a-slug-in-django.

Добавления поля Slug в таблицу категорий
........................................
Для того, чтобы создать чистые URLы мы должны добавить поле slug (хранит название категории в виде строки, в которой все проблемы заменены дефисами) в модель ``Category``. Сначала нам необходимо импортировать функцию ``slugify`` из django, которая заменит пробелы дефисами, т. е., предложение "как заменить пробелы на дефисы в django" превратится в "как-заменить-пробелы-на-дефисы-в-django".

.. warning:: Хотя Вы можете использовать пробелы в URLах, это считается не безопасным. Прочитайте `IETF памятку по URLам <http://www.ietf.org/rfc/rfc1738.txt>`_, чтобы узнать больше.

Затем нам надо переопределить метод ``save`` модель ``Category``, в котором мы вызовем метод ``slugify`` и обновим поле ``slug`` с помощью него. Обратите внимание, что каждый раз при изменении названия категории, slug также изменится. Измените Вашу модель как показано ниже и не забудьте импортировать метод slugify.

.. code-block:: python
	
	from django.template.defaultfilters import slugify

	class Category(models.Model):
		name = models.CharField(max_length=128, unique=True)
		views = models.IntegerField(default=0)
		likes = models.IntegerField(default=0)
		slug = models.SlugField()
		
		def save(self, *args, **kwargs):
			self.slug = slugify(self.name)
			super(Category, self).save(*args, **kwargs)

		def __unicode__(self):  # используйте __str__ в Python 3.*
			return self.name

После того как Вы осуществили обновление модели, необходимо выполнить миграцию.

.. code-block:: python

	$ python manage.py makemigrations rango
	$ python manage.py migrate
	
	
Поскольку мы не задали значение по умолчанию для slug и у нас уже существуют данные в модели, то команда *migrate* предоставит Вам два варианта. Выберите вариант, в котором предлагается задать значение по умолчанию и введите ''. Эта пустая строка будет вскоре перезаписана. Теперь повторно запустите Ваш скрипт для заполнения базы данных. Поскольку метод ``save`` в скрипте вызывается для каждой категории, вместо него будет выполняться переопределенный метод ``save``, обновляя поле slug. Запустите сервер и проверьте данные в моделях через интерфейс администратора.

В интерфейсе администратора Вы можете захотеть, чтобы автоматически осуществлялось повторное заполнение поля slug при вводе названия категории. Для этого Вы можете изменить ``rango/admin.py``, записав в него следующий код:

.. code-block:: python

	
	from django.contrib import admin
	from rango.models import Category, Page

	# ДОбавляем этот класс, чтобы изменить интерфейс администратора
	class CategoryAdmin(admin.ModelAdmin):
	    prepopulated_fields = {'slug':('name',)}

	# Обновляем регистрацию, чтобы она включала этот измененный интерфейс
	admin.site.register(Category, CategoryAdmin)
	admin.site.register(Page)


Опробуйте измененный интерфейс администратора и добавьте новую категорию. Правда здорово? После того как мы добавили поля slug, мы можем использовать их для чистых URLов :-).

Последовательность действий для создания страницы с категориями
...............................................................
После выбора вида URL, начнем создавать страницы. Мы реализуем следующие этапы.

#. Импортируем модель Page в ``rango/views.py``.
#. Создадим новое представление в ``rango/views.py`` - под названием ``category`` - представление ``category`` будем принимать дополнительный парамер, ``category_name_url``, где будет хранится закодированное название категории.
	* Нам будут необходимы некоторые вспомогательные функции для кодирования и декодирования ``category_name_url``.
#. Создать новый шаблон ``templates/rango/category.html``.
#. Обновить ``urlpatterns`` Rango, чтобы сопоставить новое представление ``category`` URL шаблону в ``rango/urls.py``.

Мы также должны обновить представление ``index()`` и шаблон ``index.html``, чтобы создать ссылки на представление страницы с категориями.

Представление Category
......................
В ``rango/views.py``, нам сначала нужно импортировать модель ``Page``. Для этого мы должны добавить следующую команду импорта в начале файла.

.. code-block:: python
	
	from rango.models import Page

Затем мы добавим наше новое представление, ``category()``.

.. code-block:: python
	
	def category(request, category_name_slug):
	    
	    # Создаем словарь контекста, который мы можем передать механизму обработки шаблонов.
	    context_dict = {}
	    
	    try:
	        # Можем ли мы найти название категории с дефисами для заданного названия?
	        # Если нет, метод .get() вызывает исключение DoesNotExist.
	        # Итак метод .get() возвращает экземпляр модели или вызывает исключение.
	        category = Category.objects.get(slug=category_name_slug)
	        context_dict['category_name'] = category.name
	        
	        # Получит ьвсе связанные страницы.
	        # Заметьте, что фильтр возвращает >= 1 экземпляр модели.
	        pages = Page.objects.filter(category=category)
	        
	        # Добавить наш список результатов к контексту модели под названием pages ("страницы").
	        context_dict['pages'] = pages
	        # Мы также добавWe объект категории из базы данных в словарь контекста.
	        # Мы будем использовать это информацию в шаблоне, чтобы проверить, что категория существует.
	        context_dict['category'] = category
	    except Category.DoesNotExist:
	        # Мы попадаем сюда, если не нашли указанной категории.
	        # Ничего делать не надо - шаблон отобразить сообщение "Нет такой категории" вместо нас.
	        pass
	    
	    # Возврщаем ответ на запрос клиенту.
	    return render(request, 'rango/category.html', context_dict)

При создании нашего нового представления мы использовали те же основные этапы, что и для нашего представления ``index()``. Сначала мы определили словарь контекста, затем попытались извлечь данные из модели и добавить соответствующие данные в словарь контекста. Мы определили категорию по значению, передаваемому в виде параметра ``category_name_slug`` в функцию-представление ``category()``. Если категория существует в модели Category, то мы можем затем извлечь соответствующие страницы и добавить их к словарю контекста - ``context_dict``.

Шаблон Category
...............
Теперь давайте создадим наш шаблон для нового представления. В каталоге ``<рабочее пространство>/tango_with_django_project/templates/rango/``, создайте ``category.html``. В новый файл добавьте следующий код.

.. code-block:: html
	
	<!DOCTYPE html>
	<html>
	    <head>
	        <title>Rango</title>
	    </head>
	
	    <body>
	        <h1>{{ category_name }}</h1>
	        {% if category %}
	            {% if pages %}
	            <ul>
	                {% for page in pages %}
	                <li><a href="{{ page.url }}">{{ page.title }}</a></li>
	                {% endfor %}
	            </ul>
	            {% else %}
	                <strong>No pages currently in category.</strong>
	            {% endif %}
	        {% else %}
	            The specified category {{ category_name }} does not exist!
	        {% endif %}
	    </body>
	</html>

Пример HTML кода опять показывает, как мы используем данные, передаваемые в шаблон с помощью его контекста. Мы используем переменную ``category_name`` и наши объекты ``category`` и ``pages``. Если ``category`` не определена в нашем контексте шаблона, то категория не была найдена в базе данных, и отображается сообщение об ошибке, указывающее об этом. Если категория была найдена, то мы проверяем есть ли в ней ``pages``. Если ``pages`` не определены или не содержат ничего, мы отображаем сообщение о том, что страниц не существует. В противном случае, страницы в категории представляются в виде HTML списка. Для каждой страницы в списке ``pages`` мы используем атрибуты ``title`` и ``url``.

.. note:: Условный тег шаблона Django - ``{% if %}`` - на самом деле отличный способ определить наличие объекта в контексте шаблона. Постарайтесь привыкнуть выполнять эти проверки, чтобы уменьшить область потенциальных исключений, которые могут возникнуть в вашем коде.
	
	Размещение условных проверок в Ваши шаблоны - таких как ``{% if category %}`` в вышеприведенном примере - также имеет семантический смысл. Результат условной проверки непосредственно влияет на то, как страница, созданная на основе шаблона, будет представлена пользователю - особенности представления страницы Вашего Django приложений должны быть инкапсулированы в шаблоны.

URL сопоставление с параметрами
...............................
Теперь давайте рассмотрим как передать значение параметра ``category_name_url`` в функцию ``category()``. Для этого необходимо модифицировать файл Rango ``urls.py`` и обновить кортеж ``urlpatterns`` следующим образом.

.. code-block:: python
	
	urlpatterns = patterns('',
	    url(r'^$', views.index, name='index'),
	    url(r'^about/$', views.about, name='about'),
	    url(r'^category/(?P<category_name_slug>[\w\-]+)/$', views.category, name='category'),)  # Новая строка!

Как видите, мы довольно сложную строку, которая будет вызывать ``view.category()``, когда произойдет совпадение с регулярным выражением ``r'^(?P<category_name_slug>\w+)/$'``. Мы составили наше регулярное выражение так, чтобы оно искало любую последовательность алфавитно-цифровых символов (например, a-z, A-Z или 0-9) и дефисов (-) перед последним слешем в URL. Это значение затем передается в представление ``views.category()`` в виде параметра ``category_name_slug`` - единственного аргумента после обязательного аргумента ``request``.

.. note:: Если Вы хотите использовать URLы с параметрами, важно убедиться, что ваш URL шаблон имеем столько же параметров, сколько принимает соответствующее представление. Чтобы лучше исследовать эту проблему, давайте рассмотрим вышеприведенный пример. Шаблон был добавлен следующим образом:

	.. code-block:: python
		
		url(r'^category/(?P<category_name_slug>[\w\-]+)/$', views.category, name='category')
	
	Здесь мы можем сделать вывод, что символы (алфавитно-цифровые и дефисы) между ``category/`` и ``/`` в конце совпавшего URL будут переданы методу ``views.category()`` в виде именнованного параметра ``category_name_slug``. Например, URL ``category/python-books/`` приведет к тому, что в ``category_name_slug`` запишется ``python-books``.

	Вероятно Вы помните, что все функции-представления определяемые как часть Django проекта *должны* принимать хотя бы один параметр. Он обычно называется ``request`` и обеспечивает доступ к информации, связанной с заданным HTTP запросом, сделанным пользователем. При использовании URLов с параметрами, Вы должны передавать дополнительные именованные параметры в набор аргументов для заданного представления. Используя этот же пример, наше представление ``category`` изменяется так, что теперь выглядит следующим образом.

	.. code-block:: python
		
		def category(request, category_name_slug):
		    # ... остальной код представления ...
	
	Положение дополнительных параметров не имеет значения, только *название* должно соответствовать чему-либо, определяемому в URL шаблоне. Обратите внимание на то как ``category_name_slug``, определяемое в URL шаблоне соответствует параметру ``category_name_slug``, определяемому для нашего вида. Используя ``category_name_slug`` в нашем представлении мы передаем ``python-books`` или любое значение, которое было введено в той части URL.

.. note:: Регулярные выражения могут казаться устрашающими и запутанными на первый взгляд, но существует множество ресурсов онлайн, которые могут помочь Вам. `Эта шпаргалка <http://cheatography.com/davechild/cheat-sheets/regular-expressions/>`_ - прекрасный ресурс для решения проблем, связанных с регулярными выражениями.

Изменение шаблона Index
.......................
Наше новое представление настроено и готово к работе - но нам необходимо сделать ещё кое-что. Наш шаблон для главной страницы нужно изменить, чтобы пользователь смог просмотреть перечисленные страницы с категориями. Теперь можно обновить шаблон ``index.html`` так, чтобы в нём была ссылка на страницу с категорией, используя slug.

.. code-block:: html
	
	<!DOCTYPE html>
	<html>
	    <head>
	        <title>Rango</title>
	    </head>

	    <body>
	        <h1>Rango says..hello world!</h1>

	        {% if categories %}
	            <ul>
	                {% for category in categories %}
	                <!-- Следующая строка была изменена и в неё была добавлена HTML гиперссылка -->
	                <li><a href="/rango/category/{{ category.slug }}">{{ category.name }}</a></li>
	                {% endfor %}
	            </ul>
	       {% else %}
	            <strong>There are no categories present.</strong>
	       {% endif %}

	    </body>
	</html>

В вышеприведенном блоке кода мы изменили каждый элемент списка (``<li>``), добавив к нему HTML гиперссылку (``<a>``). Гиперссылка имеет атрибут  ``href``, который мы используем, чтобы определить требуемый URL, определяемый ``{{ category.slug }}``. 

Пример работы
.............
Давайте посмотрим, что у нас получилось, посетив домашнюю страницу Rango. Вы должны увидеть домашнюю страницу со списком всех категорий. Теперь все категории должны быть активными ссылками. При нажатии на ``Python`` Вы должны перейти к просмотру категории ``Python``, как показано на рисунке :num:`fig-rango-links`. Если Вы видите список ссылок, например, ``Official Python Tutorial``, то Вы успешно создали новое представление. Попытайтесь перейти в катагорию, которой не существует, например ``/rango/category/computers``. Вы должны увидеть сообщение, сообщающее о том, что в этой категории нет страниц.

.. _fig-rango-links:

.. figure:: ../images/rango-links.png
	:figclass: align-center

	Так теперь должна выглядеть Ваша структура ссылок. Начиная с домашней страницы Rango, Вы затем можете перейти на страницу категории. Нажав на ссылку на странице Вы перейдете на связанный с ней веб сайт.
	
Упражнения
----------
Закрепите то, о чем Вы узнали в этой главе, пытаясь выполнить следующие упражнения.

* Измените домашнюю страницу так, чтобы она также включала 5 самых просматриваемых страниц.

* Изучите `третью часть официального учебного пособия по Django <https://docs.djangoproject.com/en/1.7/intro/tutorial03/>`_, если Вы не сделали это до сих пор, чтобы ещё больше закрепить то, чему Вы здесь научились.

Подсказки к упражнениям
.......................
Следующие подсказки помогут Вам выполнить упражнения, приведенные выше. Удачи!

* Обновите скрипт для заполнения базы данных, добавив в него некоторое значение для числа просмотров каждой страницы.

