.. _test-chapter:

Автоматизированное тестирование
===============================
Хорошей привычкой считается написание и разработка тестов. Значительная часть проектирования программного обеспечения связана с написанием и разработкой тестов и тестовых наборов, гарантирующих надежную работу программного обеспечения. Конечно, большую часть времени мы слишком заняты созданием программы, не заботясь о том, насколько надежно она работает. Или слишком самонадеянно полагаем, что она не откажет.

В соответствии с `учебным пособием по Django <https://docs.djangoproject.com/en/1.7/intro/tutorial05/>`_, существует множество причин, почему необходимо добавлять тесты в приложение:

* Тесты помогут Вам сэкономить время: изменение в сложной системе может привести к сбоям в непредсказуемых местах.
* Тесты не только выявляют проблемы, но и могут предотвращать их: тесты показывают, где код не соответствует требованиям.
* Тесты могут сделать Ваш код более привлекательным: "Код без тестов нарушает дизайн" - так говорит Яков Каплан-Мос - один из первоначальных разработчиков Django.
* Тесты упрощают совместную работу: они гарантируют, что Ваши коллеги случайно не нарушат правильную работу Вашего кода.

Согласно руководству по Python `<http://docs.python-guide.org/en/latest/writing/tests/>`_, существует ряд общих правил, которым Вы должны стараться следовать при написании тестов. Ниже приведены некоторые основные правила:

* Тесты должны проверять работоспособность какой-то одной функции;
* Тесты должны иметь четкую цель;
* Тесты должны быть независимыми;
* Создавайте тесты перед написанием кода и перед переносом Вашего кода на удаленный репозиторий;
* Еще лучше создать хук, который проверяет код перед передачей на удаленный репозиторий;
* Для тестов используйте длинные и описывающие назначение названия .

.. note:: В настоящее время в этой главе представлен минимум сведений о тестировании и она имеет форма аналогичный `учебному пособию по Django <https://docs.djangoproject.com/en/1.7/intro/tutorial05/>`_, с некоторыми дополнительными примечаниями. Мы надеемся расширить её в будущем.


Запускаем тесты
---------------
В Django существует встроенный механизм для тестирования создаваемых приложений. Чтобы запустить тест, выполните следующую команду:

.. code-block:: guess

	$ python manage.py test rango
	
	Creating test database for alias 'default'...

	----------------------------------------------------------------------
	Ran 0 tests in 0.000s

	OK
	Destroying test database for alias 'default'...
	
Она запустит тесты, связанные с приложением Rango. В настоящий момент ничего не произойдет. Это связано с тем, что как Вы наверное заметили файл ``rango/tests.py`` содержит только оператор импорта. Каждый раз, когда Вы создаете приложение, Django автоматически создает такой файл, мотивируя Вас написать тесты.

Из сообщений в окне терминала видно, что происходит запрос к базе данных ``default``. При запуске тестов создается временная база данных, которую Ваши тесты могут заполнить и над которой они могут осуществлять операции. Таким образом, Ваше тестирование происходит независимо, не затрагивая информацию в реальной базе данных.

Тестирование моделей в Rango
----------------------------
Давайте создадим тест. В модели Category мы хотим убедиться, что количество просмотров или равно нулю или является положительным числом, поскольку оно никогда не может быть меньше нуля. Чтобы создать тест, мы можем добавить следующий код в ``rango/tests.py``:

.. code-block:: python


	from django.test import TestCase

	from rango.models import Category

	class CategoryMethodTests(TestCase):

	    def test_ensure_views_are_positive(self):

	        """
			функция ensure_views_are_positive должна возвращать True для категорий, у которых число просмотров равно нулю или положительное
	        """
			cat = Category(name='test',views=-1, likes=0)
			cat.save()
			self.assertEqual((cat.views >= 0), True)

Первое, что Вы должны заметить, если не писали тесты раньше, это то, что мы должны наследовать тест от класса TestCase. Название метода в классе также следует принятому соглашению, что все тесты начинаются со слова ``test_`` и также содержат некоторое проверяемое предположение. Здесь мы проверяем, что значения равны с помощью метода ``assertEqual``, но существуют и другие виды предположений. Смотри документацию к Python по тестированию модулей, https://docs.python.org/2/library/unittest.html, чтобы узнать о других командах (т. е., ``assertItemsEqual``, ``assertListEqual``, ``assertDictEqual`` и т. д.). Механизм тестирования Django создан на основе механизма для языка Python, но также предоставляет ряд других предположений и особых случаев тестирования.

Теперь давайте запустим тест:

.. code-block::  guess

	$ python manage.py test rango
	
	
	Creating test database for alias 'default'...
	F
	======================================================================
	FAIL: test_ensure_views_are_positive (rango.tests.CategoryMethodTests)
	----------------------------------------------------------------------
	Traceback (most recent call last):
	  File "/Users/leif/Code/tango_with_django_project_17/rango/tests.py", line 12, in test_ensure_views_are_positive
	    self.assertEqual((cat.views>=0), True)
	AssertionError: False != True

	----------------------------------------------------------------------
	Ran 1 test in 0.001s

	FAILED (failures=1)
	

Как видно этот тест был пройден не удачно. Это связано с тем, что модель не проверяет является ли значение ``количество просмотров`` меньше нуля или нет. Поскольку мы действительно хотим гарантировать, что значения не нулевые, нужно изменить модель для того, чтобы это требование выполнялось. Сделаем это сейчас, добавив в модели Catgegory метод ``save()``, который проверяет значение количества просмотров и обновляет его соответствующим образом.

Как только Вы обновите Вашу модель, Вы можете перезапустить тест и посмотреть проходит ли теперь его Ваш код. Если нет, найдите ошибку и опять запустите тест.

Давайте попытаемся добавить другой тест, который гарантирует, что создана соответствующая строка slug, т. е., состоящая из дефисов и символов в нижнем регистре. Добавьте следующий код в ``rango/tests.py``:

.. code-block:: python


	   def test_slug_line_creation(self):
	   		"""
			Функция slug_line_creation проверяет, была ли создана при добавлении категории соответствующая строка slug, т. е., например, строка "Random Category String" должна преобразовываться в "random-category-string"
			"""

			cat = cat('Random Category String')
			cat.save()
			self.assertEqual(cat.slug, 'random-category-string')


Прошел ли Ваш код проверку на работоспособность после запуска этого теста?

Тестирование представлений
--------------------------
До сих пор мы писали тесты, предназначенные для проверки целостности данных, хранящихся в моделях. Django также предоставляет механизмы тестирования для проверки представлений. Для этого он имитирует клиента, который изнутри вызывает Django представление через URL. В тесте у Вас есть доступ к ответу сервера на запрос (включая HTML код) и словарю контекста.

Давайте создадим тест, который проверяет, что при загрузке главной страницы, она отображает сообщение ``There are no categories present``, когда модель Category не содержит категорий.

.. code-block:: python

	from django.core.urlresolvers import reverse


	class IndexViewTests(TestCase):

	    def test_index_view_with_no_categories(self):
	        """
	        Если не существует категорий, то должно выводиться соответствующее сообщение.
	        """
	        response = self.client.get(reverse('index'))
	        self.assertEqual(response.status_code, 200)
	        self.assertContains(response, "There are no categories present.")
	        self.assertQuerysetEqual(response.context['categories'], [])
	

Прежде всего класс Django ``TestCase`` имеет доступ к объекту ``client``, который может создавать запросы. Здесь он использует вспомогательную функцию ``reverse``, для поиска URL страницы ``index``. Затем он пытается получить эту страницу, в которой находится ``response``. Тест осуществляет несколько проверок: загрузилась ли страница с кодом статуса 200 OK? Содержит ли ответ от сервера, т. е., HTML код фразу "There are no categories present." и содержит ли словарь контекста пустой список категорий. Вспомните, что когда Вы запускаете тесты, создается новая база данных, которая по умолчанию не заполняется.

Давайте теперь проверим представление в случае, когда существуют категории. Сначала добавьте вспомогательный метод.

.. code-block:: python

	from rango.models import Category

	def add_cat(name, views, likes):
    	c = Category.objects.get_or_create(name=name)[0]
    	c.views = views
    	c.likes = likes
    	c.save()
    	return c


Затем другой метод в ``класс IndexViewTests(TestCase)``:


.. code-block:: python	

    def test_index_view_with_categories(self):
        """
        Если не существует категорий, то должно выводиться соответствующее сообщение.
        """

        add_cat('test',1,1)
        add_cat('temp',1,1)
        add_cat('tmp',1,1)
        add_cat('tmp test temp',1,1)

        response = self.client.get(reverse('index'))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "tmp test temp")

        num_cats =len(response.context['categories'])
        self.assertEqual(num_cats , 4)

В этом тесте мы заполняем базу данных четырьмя категориями и затем проверяем загрузилась ли страница с кодом статуса 200 OK, содержит ли она текст ``tmp test temp`` и равно ли число категорий четырем.

#TODO(leifos): add in some tests showing how to test different forms i.e. login etc.

Тестирование выдаваемой страницы
--------------------------------
#TODO(leifos): add an example using either Django's test client and/or Selenium, which is are "in-browser" frameworks to test the way the HTML is rendered in a browser.


Покрытие кода тестами
---------------------
Покрытие кода определяет насколько Ваш код был протестирован и какая часть Вашего кода успешно прошла тесты. Вы можете установить пакет ``coverage`` с помощью команды ``pip install coverage``, который автоматически анализирует Ваше покрытие кода. После установки пакета ``coverage``, запустите следующую команду:

.. code-block:: guess

	$ coverage run --source='.' manage.py test rango
	
Она выполнит все тесты и выдаст данные о покрытии для приложения Rango. Чтобы увидеть отчет о покрытии, введите:

.. code-block:: guess

	$ coverage report
	
	Name                                       Stmts   Miss  Cover
	--------------------------------------------------------------
	manage                                         6      0   100%
	populate                                      33     33     0%
	rango/__init__                                 0      0   100%
	rango/admin                                    7      0   100%
	rango/forms                                   35     35     0%
	rango/migrations/0001_initial                  5      0   100%
	rango/migrations/0002_auto_20141015_1024       5      0   100%
	rango/migrations/0003_category_slug            5      0   100%
	rango/migrations/0004_auto_20141015_1046       5      0   100%
	rango/migrations/0005_userprofile              6      0   100%
	rango/migrations/__init__                      0      0   100%
	rango/models                                  28      3    89%
	rango/tests                                   12      0   100%
	rango/urls                                    12     12     0%
	rango/views                                  110    110     0%
	tango_with_django_project/__init__          0      0   100%
	tango_with_django_project/settings         28      0   100%
	tango_with_django_project/urls              9      9     0%
	tango_with_django_project/wsgi              4      4     0%
	--------------------------------------------------------------
	TOTAL                                        310    206    34%
	

Из приведенного выше отчета видно, что критически части кода не были протестированы, т. е., ``rango/views``. Чтобы узнать больше об использовании пакета ``coverage`` посетите страницу http://nedbatchelder.com/code/coverage/ .

Упражнения
----------

* Допустим, что мы хотим расширить модель ``Page``, добавив в неё два дополнительных поля ``last_visit`` (дата последнего посещения страницы) и ``first_visit`` (дата первого посещения страницы), имеющие тип ``timedate``;
	* Измените модель, добавив эти два поля;
	* Обновите функции ``add page`` и ``goto``.
	* Добавьте тест, проверяющий, что дата последнего посещения страницы или первого посещения страницы не в будущем.
	* Добавьте тест, гарантирующий что дата последнего посещения страницы равна или позже даты первого посещения страницы.
	* Просмотрите `Пятую часть официального учебного пособия по Django <https://docs.djangoproject.com/en/1.7/intro/tutorial05/>`_, которая поможет создать эти тесты.

* Просмотрите `учебное пособие по технике разработки с помощью тестирования Гарри Песивала <http://www.tdd-django-tutorial.com>`_.

