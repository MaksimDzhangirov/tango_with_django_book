.. _forms-label:

Работа с формами
================
До сих пор мы выводили данные через представления и шаблоны, которые мы создавали. В этой главе мы узнаем, как обрабатывать данные, введенные с помощью веб форм. Django включает в себя хороший функционал для работы с формами, что делает простым процесс сбора информации от пользователей и передачу её Вашему веб приложению. В соответствии с документацией Django по формам <https://docs.djangoproject.com/en/1.7/topics/forms/>`_, функционал для работы с формами позволяет Вам:

#. выводить HTML формы с автоматически генерируемыми *виджетами форм* (такими как текстовое поле или поле для выбора даты);
#. проверять посланные данные, используя набор правил для проверки;
#. повторно отображать в случае ошибок при проверке; и
#. преобразовывать посланные данные формы в соответствующие типы данных Python.

Одно из главных преимуществ использования Django функционала для работы с формами заключается в том, что Вы можете сэкономить время и освободит от написания HTML кода. В этой части учебного пособия мы рассмотрим, как реализовать необходимую инфраструктуру, которая позволит пользователям Rango добавлять категории и страницу в базу данных через формы.

Основная последовательность действий
------------------------------------
Ниже приведены основные этапы, входящие в создание формы, которая позволяет пользователям вводить данные.

#. Если Вы ещё этого не сделали этого, то создайте файл ``forms.py`` в каталоге Вашего Django приложения для хранения классов, связанных с формой.
#. Создайте класс ``ModelForm`` для каждой модели, которая должна быть представлена в виде формы.
#. Настройте форму по Вашему усмотрению.
#. Создайте или измените представление, которое будет обрабатывать данные формы - включая *отображение* формы, *сохранение* данных формы и *сигнализацию ошибок*, которые могут возникать, когда пользователь ввел неправильные данные (или вообще не ввел данные) в форму.
#. Создание или изменение шаблона для отображения формы.
#. Добавление ``URL шаблона`` для сопоставления новому представлению (если Вы создали новое).

Эта последовательность действий немного сложнее, чем предыдущие, и представления, которые мы будем создавать также гораздо более сложные. Однако, как только Вы повторите процесс несколько раз, Вам всё станет понятно.

Формы для страницы и категории
------------------------------
Сначала создадим файл под названием ``forms.py`` в каталоге приложения ``rango``. Хотя этот шаг не является обязательным, поскольку Вы можете хранить формы в ``models.py``, это деляет код чище и понятнее.

Создание классов ``ModelForm``
..............................
В модуле Rango ``forms.py`` мы создадим несколько классов, которые будут наследоватться от класса Django ``ModelForm``. По существу, `ModelForm <https://docs.djangoproject.com/en/1.7/topics/forms/modelforms/#modelform>`_ - это *вспомогательный класс*, который позволяет Вам создавать Django ``форму`` из существующей модели. Поскольку у нас уже есть две модели, определенные для Rango (``Category`` и ``Page``), мы создадим ``ModelForms`` для обоих.

В ``rango/forms.py`` добавьте следующий код.

.. code-block:: python
	
	from django import forms
	from rango.models import Page, Category
	
	class CategoryForm(forms.ModelForm):
	    name = forms.CharField(max_length=128, help_text="Please enter the category name.")
	    views = forms.IntegerField(widget=forms.HiddenInput(), initial=0)
	    likes = forms.IntegerField(widget=forms.HiddenInput(), initial=0)
	    slug = forms.CharField(widget=forms.HiddenInput(), required=False)
		
	    # Вложенный класс позволяющий задавать дополнительную информацию о форме
	    class Meta:
	        # Создаем связь между ModelForm и моделью
	        model = Category
	        fields = ('name',)
	
	
	class PageForm(forms.ModelForm):
	    title = forms.CharField(max_length=128, help_text="Please enter the title of the page.")
	    url = forms.URLField(max_length=200, help_text="Please enter the URL of the page.")
	    views = forms.IntegerField(widget=forms.HiddenInput(), initial=0)

	    class Meta:
	        # Создаем связь между ModelForm и моделью
	        model = Page

	        # Какие поля мы хотим включить в нашу форму?
	        # На мне обязательно добавлять каждое поле, существующее в модели.
	        # Некоторые поля могут иметь значения NULL, поэтому мы не захотим добавлять их...
	        # Здесь мы скрываем внешний ключ.
	        # Мы можем либо исключить поле category из формы,
	        exclude = ('category',)
	        # или определить поля, которые надо в неё добавить (т. е., не добавлять поле category)
	        #fields = ('title', 'url', 'views')
			
			
#TODO(leifos): Note that in Django 1.7+ it is now required to specify the fields that are included, via ``fields``, or specify the fields that are to be excluded, via ``exclude``.

Django предоставляет нам несколько способов настройки созданных форм. В вышеприведенном примере кода, мы определили виджеты, которые мы хотим использовать для каждого отображаемого поля. Например, в нашем классе ``PageForm`` мы определили ``forms.CharField`` для поля ``title`` и ``forms.URLField`` для поля ``url``. Оба поля позволяют вводить текстовые данные пользователям. Обратите внимание, что параметры ``max_length``, передаваемые нашим полям совпадают с максимальной длиной каждого поля, которые мы определили в моделях данных, лежащих в их основе. Вернитесь к главе :ref:`model-label`, чтобы освежить информацию о моделях в памяти или взглянуть на файл ``models.py`` Rango.

Вы также заметите, что мы включили несколько полей для просмотров и лайков в каждой форме. Заметьте, что мы создали виджет скрытым с параметром ``widget=forms.HiddenInput()`` и затем установили значение равное нулю с помощью ``initial=0``. Это один из способов установить поле равным нулю, не давая изменять его пользователю, поскольку поле будет скрыто, но так, чтобы форма смогла передать значение в модель. Тем не менее, как видно в ``PageForm``, несмотря на то, что мы имеем скрытое поле, нам все равно необходимо добавить поле в форму. Если в ``fields`` мы исключили ``views``, то форма не будет содержать поле (даже если указать его) и поэтому форма не будет возвращать нулевое значение для этого поля. Это может привести к ошибке, в зависимости от того как была создана модель. Если в моделях мы указали, что ``default=0`` для этих полей, то мы можем рассчитывать на то, что модель автоматически заполнит поле значением по умолчанию и таким образом удастся избежать ошибки ``not null``. В этом случае, не обязательно задавать эти скрытые поля. Мы также добавили поле ``slug`` в форму и настроили её, используя ``widget=forms.HiddenInput()``, но вместо указания начального значения или значения по умолчанию, мы прописали, что поле не требуется для формы. Это связано с тем, что при сохранении формы (``save()``) наша модель будет отвечать за заполнение этого поля. Это означает, что необходимо быть осторожным при определении Ваших моделей и форм, чтобы гарантировать, что форма содержит и передает все данные, которые требуются для правильного заполнения Вашей модели.

Кроме виджетов ``CharField`` и ``IntegerField`` доступны и другие для использования. Например, в Django существует ``EmailField`` (для ввода адреса e-mail), ``ChoiceField`` (для радиокнопок) и ``DateField`` (для ввода даты/времени). Существует много других типов полей, которые Вы можете использовать, осуществляющие проверку на ошибки введенных данных за Вас (например, *действительно ли введенное значение является целым числом?*). Мы настоятельно рекомендуем просмотреть `официальную Django документацию по виджетам <https://docs.djangoproject.com/en/1.7/ref/forms/widgets/>`_, чтобы увидеть какие компоненты существуют и какие аргументы Вы можете указать для их настройки.

Возможно наиболее важной особенностью класса, наследуемого от ``ModelForm`` является то, что необходимо определить *для какой модели мы хотим создать форму*. Мы определяем это в нашем вложенном классе ``Meta``. Присвойте атрибуту ``model`` вложенного класса ``Meta`` модель, которую Вы хотите использовать. Например, наш класс ``CategoryForm`` содержит ссылку на модель ``Category``. Этот важный шаг позволяет Django создать форму на основе указанной модели. Это также поможет при сигнализации любых ошибок, сохранении и отображении данных в форме.

Мы также использовали класс ``Meta``, чтобы определить какие поля мы хотим включить в нашу форму с помощью кортежа ``fields``. Используйте кортеж имен полей, чтобы указать поля, которые нужно добавить в форму.


.. note:: Мы настоятельно рекомендуем Вам прочитать `официальную Django документацию по формам <https://docs.djangoproject.com/en/1.7/ref/forms/>`_, чтобы узнать больше о том как их можно настроить.

Создание представления *Добавить категорию* (Add Category)
..........................................................
После определения нашего класса ``CategoryForm``, теперь мы готовы создать новое представление для отображения формы и обработки введенных в форму данных. Для этого добавьте следующий код в ``rango/views.py``.

.. code-block:: python
	
	from rango.forms import CategoryForm
	
	def add_category(request):
	    # HTTP POST?
	    if request.method == 'POST':
	        form = CategoryForm(request.POST)

	        # Все поля формы были заполнены правильно?
	        if form.is_valid():
	            # Сохранить новую категорию в базе данных.
	            form.save(commit=True)

	            # Теперь вызвать предсталвение index().
	            # Пользователю будет показана главная страница.
	            return index(request)
	        else:
	            # Обрабатываемая форма содержит ошибки - вывести их в терминал.
	            print form.errors
	    else:
	        # Если запрос был не POST, вывести форму, чтобы можно было ввести в неё данные.
	        form = CategoryForm()

	    # Форма с ошибкой (или ошибка с данных), форма не была получена...
	    # Вывести форму с сообщениями об ошибках (если они были).
	    return render(request, 'rango/add_category.html', {'form': form})

Новое представление ``add_category()`` добавляет несколько ключевых элементов функциональности для обработки форм. Во-первых, мы проверяем HTTP метод запроса, чтобы определить был ли это HTTP ``GET`` или ``POST``. Затем мы можем обработать различные методы запросов соответствующим образом - т. е., независимо от того мы хотим показать форму (в этом случае используется метод ``GET``) или обработать данные формы (в этом случае используется метод ``POST``) - используется один и тот же URL. Функция-представление ``add_category()`` может работать в трех различных режимах:

- показывать новую, пустую форму для добавления категории;
- сохранять данные форму, введенные пользователем в соответствующую модель, и выдавать главную страницу Rango; и
- если возникли ошибки, повторно отображать форму с сообщениями об ошибках.

.. note::
	
	Что мы имеем в виду под ``GET`` и ``POST``? Существует два различных типа *HTTP запросов*.

	- HTTP ``GET`` используется для *запроса содержимого указанного ресурса.* Другими словами, мы используем HTTP ``GET`` для получения конкретного ресурса, например, веб страницы, изображения или другого файла.
	- Напротив, HTTP ``POST`` *применяется для передачи данных веб браузера клиента.* Этот тип запроса используется, например, при отправке содержимого HTML формы.
	- Наконец, HTTP ``POST`` может использоваться для создания нового ресурса (например, новой записи в базе данных) на сервере. В дальнейшем к ней можно получить доступ через HTTP ``GET`` запрос.

Механизм обработки форма Django работает c данными, переданными браузером пользователя, через HTTP ``POST`` запрос. Он не только может сохранить данные формы в выбранную модель, но также автоматически генерировать сообщения об ошибках для каждого поля формы (если необходимо). Это означает, что Django не сохранит какую-либо оправленную форму с отсутствующей информацией, которая потенциально может привести к проблемам целостности Вашей базы данных. Например, если не ввести значение в поле с названием категории, будет выведена ошибка о том, что поле не может быть пустым.

Заметьте, что в строке, где мы вызвали ``render()`` использовался новый шаблон - ``add_category.html``, который будет содержать соответствующий код шаблона Django и HTML для формы и страницы.

Создание шаблона *Добавить категорию* (Add Category)
....................................................
Создайте файл ``templates/rango/add_category.html``. В файл добавьте следующую HTML разметку и код шаблона Django.

.. code-block:: html
	
	<!DOCTYPE html>
	<html>
	    <head>
	        <title>Rango</title>
	    </head>

	    <body>
	        <h1>Add a Category</h1>

	        <form id="category_form" method="post" action="/rango/add_category/">

	            {% csrf_token %}
	            {% for hidden in form.hidden_fields %}
	                {{ hidden }}
	            {% endfor %}	

	            {% for field in form.visible_fields %}
	                {{ field.errors }}
	                {{ field.help_text }}
	                {{ field }}
	            {% endfor %}

	            <input type="submit" name="submit" value="Create Category" />
	        </form>
	    </body>
	
	</html>

Что делает этот код? Внутри тега ``<body>`` HTML страницы мы поместили элемент ``<form>``. Посмотрев на атрибуты элемента ``<form>`` видно, что все данные, введенные в эту форму, будут посылаться в URL ``/rango/add_category/`` в виде HTTP POST запроса (атрибут ``method`` не чувствителен к регистру, поэтому Вы можете ввести ``POST`` и ``post`` - не почувствовав разницы). Внутри формы выполняют два цикла - один для *скрытых полей* формы, другой для *видимых* полей формы - где видимые поля определяются атрибутом ``fields`` вложенного класса ``Meta`` Вашего класса ``ModelForm``. Эти циклы создают HTML разметку для каждого элемента формы. Для видимых полей форм мы также добавляем шаблоны для любых ошибок, которые могут возникать для конкретного поля и вспомогательный текст, который будет использоваться, чтобы объяснить пользователю, что он или она должны ввести.

.. note:: Необходимость скрытых и видимых полей объясняется тем, что HTTP - это протокол, не сохраняющий своего состояния. Вы не можете сохранять состояние между различными HTTP запросами, что может усложнить реализацию определенных частей веб приложений. Для решения этой проблемы, создаются скрытые поля HTML формы, которые позволяют веб приложениям передавать важную информацию клиенту (которая не видна на выдаваемой странице) в HTML форме, только чтобы послать её обратно серверу, когда пользователь отправит форму.

Также обратите внимание на код ``{% csrf_token %}``. Это *токен защиты от межсайтовой подделки запроса*, который используется для защиты и безопасного HTTP ``POST`` запроса, который создается после отправки данных формы. CSRF токен является обязательной составляющей форм для фреймворка Djnago. Если Вы забыли добавить CSRF токен в Ваши формы, у пользователя могут возникнуть ошибки при отправке формы.* Просмотрите `официальную Django документацию о CSRF токенах <https://docs.djangoproject.com/en/1.7/ref/contrib/csrf/>`_, чтобы получить больше информации.

Сопоставление URLа представлению *Добавить категорию* (Add Category)
....................................................................
Теперь необходимо сопоставить представлению ``add_category()`` URL. В шаблоне мы использовали URL ``/rango/add_category/`` в атрибуте ``action`` формы. Следовательно, его надо использовать в ``rango/urls.py`` и изменить ``urlpatterns`` следующим образом.

.. code-block:: python
	
	urlpatterns = patterns('',
	    url(r'^$', views.index, name='index'),
	    url(r'^about/$', views.about, name='about'),
	    url(r'^add_category/$', views.add_category, name='add_category'), # НОВОЕ СОПОСТАВЛЕНИЕ!
	    url(r'^category/(?P<category_name_slug>[\w\-]+)/$', views.category, name='category'),)

Порядок шаблонов не имеет значения в этом случае. Тем не менее, просмотрите `официальную Django документацию о том как Django обрабатывает запрос <https://docs.djangoproject.com/en/1.7/topics/http/urls/#how-django-processes-a-request>`_, чтобы узнать больше. Новый URL для добавления категории - это ``/rango/add_category/``.

Изменение внешнего вида главной страницы
........................................
Наконец, давайте поместим ссылку на главной странице, чтобы мы могли легко добавлять категории. Отредактируйте шаблон ``rango/index.html`` и добавьте следующую HTML гиперссылку непосредственно перед закрывающимся тегом ``</body>``.

.. code-block:: html
	
	<a href="/rango/add_category/">Add a New Category</a><br />

Пример работы
.............
Теперь давайте проверим работоспособность написанного кода! Запустите сервер для разработки Django и перейдите по адресу ``http://127.0.0.1:8000/rango/``. Используйте Вашу новую ссылку, чтобы перейти на страницу добавления категории и попытайтесь добавить категорию. На рисунке :num:`fig-rango-form-steps` показаны снимки экрана главной страницы и страницы для добавления категории.

.. _fig-rango-form-steps:

.. figure:: ../images/rango-form-steps.png
	:figclass: align-center
	
	Добавляем новую категорию в Rango с помощью нашей новой формы. На рисунке показана последовательность шагов.
		
.. note:: Если Вы добавите несколько категорий, они могут не появиться на главной странице, потому что мы показываем только 5 первых категорий на главной странице. Если Вы войдете в интерфейс администратора, Вы сможете просмотреть все категории, которые Вы ввели. Чтобы увидеть, что происходит после ввода названия категории в представлении ``add_category()`` из файла ``rango/views.py``, Вы можете получить ссылку на объект модели категории, созданной с помощью метода ``form.save()``, следующим образом ``cat = form.save(commit=True)``. Затем распечайте в консоли категорию и slug, используя команду ``print cat, cat.slug``, чтобы увидеть, что было создано.

Проверяем данные формы
......................
Вспомним, что наша модель ``Page`` имеет атрибут ``url``, который является экземпляром типа ``URLField``. В соответствующей HTML форме, Django будет ожидать, что текст введенный в поле ``url``, будет правильно сформированным, полным URL. Однако пользователи могут посчитать громоздким вводить что-то на подобии ``http://www.url.com`` - на самом деле пользователи `могут даже не знать, что включает в себя правильный URL <https://support.google.com/webmasters/answer/76329?hl=en>`_!

В случае, когда ввод URL от пользователя может быть не правильным, мы можем *переопределить* метод ``clean()``, реализованный в ``ModelForm``. Этот метод вызывается перед сохранением данных формы в новом экземпляре модели и таким образом является логическим место, где мы можем вставить код, который можем проверить и даже исправить любые данные, которые пользователь ввел в форму. В нашем вышеприведенном примере мы можем проверить - начинается ли значение, введенное пользователем в поле ``url``, с ``http://`` - и если нет, мы можем вставить ``http://`` перед значением введенным пользователем.

.. code-block:: python

	class PageForm(forms.ModelForm):

	    ...

	    def clean(self):
	        cleaned_data = self.cleaned_data
	        url = cleaned_data.get('url')

	        # Если url не пустое и не начинается с 'http://', вставить перед ним 'http://'.
	        if url and not url.startswith('http://'):
	            url = 'http://' + url
	            cleaned_data['url'] = url

                return cleaned_data

Простую последовательность действий внутри метода ``clean()`` вы можете повторить в своей собственной реализации кода обработки Django форм.

#. Данные формы берутся из атрибута-словаря ``cleaned_data`` класса ``ModelForm``.
#. После этого поля формы, которые Вы хотите проверить на правильность ввода, могут быть извлечены из словаря ``cleaned_data``. Используйте метод ``.get()`` объекта словаря, чтобы получить значения формы. Если пользователь не ввел значение в поле формы, его не будет существовать в словаре ``cleaned_data``. В этом случае метод ``.get()`` вернет ``None``, а не вызовет исключение ``KeyError``. Это упростит Ваш код!
#. Проверьте, что для каждого поля формы, которое Вы хотите обработать, было извлечено значение. Если что-то было введено, проверьте что именно. Если это не то, что Вы ожидаете, добавьте логику для исправления этой ошибки, прежде чем *переопределить* значение в словаре ``cleaned_data`` для данного поля.
#. Вы *всегда должны* заканчивать метод ``clean()``, возвращая ссылку на словарь ``cleaned_data``. Если не сделать этого, то это приведет к ошибкам!

Этот простой пример показывает, как мы можем проверить данные, передаваемые с помощью формы, перед тем как сохранить их. Это очень удобно, особенно, когда определенные поля должны иметь значения по умолчанию - или в форме отсутствуют данные и поэтому нам необходимо решать такие проблемы с введенными данными.

.. note:: Переопределение методов, реализуемое в рамках фреймворка Django является элегантным способом придать Вашему приложению дополнительные функциональные возможности. Существует множество методов, которые Вы можете безопасно и с выгодой переопределить, например, метод ``clean()`` в классе ``ModelForm`` как показано выше. Прочитайте `официальную Django документацию по моделям <https://docs.djangoproject.com/en/1.7/topics/db/models/#overriding-predefined-model-methods>`_, где приведено больше примеров о том, как Вы можете переопределить функционал, реализуемый по умолчанию, своим собственным.

Упражнения
----------
Теперь, когда вы проработали эту главу, попытайтесь выполнить эти упражнения, чтобы закрепить Ваши знания, касающиеся работы с формами в Django.

- Что случится, если Вы не введете название категории в форму для добавления категории?
- Что случится, если Вы попытаетесь добавить категорию. которая уже существует?
- Что случится, если Вы перейдете по адресу категории, которой не существует?
- Как можно корректно обработать случай, когда пользователь переходит на страницу категории, которой не существует?
- Прочтите `четвертую часть официального учебного пособия по Django <https://docs.djangoproject.com/en/dev/intro/tutorial04/>`_, если Вы ещё не сделали этого, чтобы закрепить то, чему Вы здесь научились.

.. _forms-add-pages-view-label:

Создание представления, шаблона *Добавить стриницы* (Add Pages) и сопоставление URLа представлению
.................................................................................................
Следующий логический шаг - позволить пользователям добавлять страницы в заданную категорию. Для этого повторите вышеприведенную последовательность действий для страниц - создайте новое представление (``add_page()``), новый шаблон (``rango/add_page.html``), сопоставьте представлению URL и затем добавить ссылку на страницы категории. Чтобы помочь Вам, ниже показан код представления.

.. code-block:: python
	
	from rango.forms import PageForm
	
	def add_page(request, category_name_slug):
	
	    try:
	        cat = Category.objects.get(slug=category_name_slug)
	    except Category.DoesNotExist:
	        	cat = None

	    if request.method == 'POST':
	        form = PageForm(request.POST)
	        if form.is_valid():
	            if cat:
	                page = form.save(commit=False)
	                page.category = cat
	                page.views = 0
	                page.save()
	                # вероятно здесь лучше использовать redirect.
	                return category(request, category_name_slug)
	        else:
	            print form.errors
	    else:
	        form = PageForm()
	
	    context_dict = {'form':form, 'category': cat}

	    return render(request, 'rango/add_page.html', context_dict)
	
	
Подсказки к упражнениям
.......................
Следующие подсказки могут помочь Вам при решении вышеприведенных упражнений.

* Измените представление ``category()``, чтобы оно передавало ``category_name_slug``, вставив его в словарь представления ``context_dict``.
* Измените ``category.html`` и добавьте ссылку на ``/rango/category/<url_c_названием_категории>/add_page/``.
* Убедитесь, что ссылка появляется только когда *существует запрошенная категория* - со страницами или без, т. е., в шаблоне осуществите проверку ``{% if category %} .... {% else %} Категории с таким именем не существует {% endif %}``.
* Измените ``rango/urls.py``, добавив URL шаблон для обработки вышеприведенной ссылки.

