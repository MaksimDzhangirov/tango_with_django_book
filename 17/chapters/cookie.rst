.. _cookie-label:

Cookies и сессии
================
В этой главе мы изучим *сессии* и *cookies*, которые тесно связаны друг с другом и играют важную роль в современных веб приложениях. В предыдущей главе, фреймворк Django использовал сессии и cookies для реализации функций входа и выхода в/из системы (без нашего явного указания использовать их). Здесь мы рассмотрим, как явно использовать cookies для других целей.

Cookies, Cookies используются везде!
------------------------------------
Если вы уже знакомы с идеями и понятиеми лежащими в основе cookies, то перейдите к Разделу :ref:`model-cookies-protocols-label`.

Каждый раз при осуществлении запроса на сайт, веб-сервер возвращает содержимое запрашиваемой страницы. Кроме него может также посылаться один или несколько cookies клиенту, которые хранятся в постоянном кэше браузера. Когда пользователь запрашивает новую страницу у того же веб сервера, любые cookies, которые соответствуют этому серверу посылаются вместе с запросом. Затем сервер извлекает и обрабатывает cookies, которые передались с запросом и генерирует подходящий ответ.

Термин *cookie* на самом деле возник не от слова печенье (так переводится cookie), а от термина *magic cookie* - пакета данных, которые программа получает и затем отправляет обратно неизменными. В 1994 году MCI попросило *Netscape Communications* реализовать способ с помощью которого можно было бы хранить информацию между HTTP-запросами. Это нужно было, чтобы надежно хранить содержимое виртуальной корзины покупок пользователя для приложения электронной коммерции, которое они разрабатывали. Программист Netscape Лу Монтулли использовал понятие magic cookie и применил его для веб коммуникаций. Вы можете узнать больше о `cookies и их истории на Википедии <http://en.wikipedia.org/wiki/HTTP_cookie#History>`_. Конечно после такой великолепной идеи, Монтулли подал заявку на патент, который можно прочитать: `US patent 5774670 <http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PALL&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.htm&r=1&f=G&l=50&s1=5774670.PN.&OS=PN/5774670&RS=PN/5774670>`_.

Например, Вы заходите на сайт, используя определенное имя пользователя и пароль. Когда Вы аутентифицированы, Вашему браузеру может быть возвращен cookie, который содержит Ваше имя пользователя, указывая на то, что Вы зашли на сайт. При каждом запросе эта информация посылается обратно на сервер, где она используется для выдачи соответствующей страницы - при этом в определенных местах страницы может быть вставлено Ваше имя пользователя. Ваш сеанс работы с браузером не может длиться вечно, поэтому cookies *истекут* через определенный промежуток времени - они не могут быть бесконечной длины. Сookies для веб приложения, содержащего конфиденциальную информацию, могут истечь через несколько минут при бездействии со стороны пользователя. Сookies для других веб приложений с не такой важной информацией могут истечь через полчаса после последнего взаимодействия или даже через недели.

Передача информации в виде cookies может привести к потенциальным проблемам безопасности при проектировании Вашего приложения. Из-за этого разработчики веб приложений должны быть очень осторожны при использовании cookies - *действительно ли необходимо* посылать информацию, которую нужно сохранить между запросами в виде cookie? Во многих случаях, существуют альтернативные и более безопасные решения проблемы. Например, не стоит передавать номер кредитной карточки пользователя сайту электронной коммерции в виде cookie. Что если компьютер пользователя взломают? Cookie может быть перехвачен вредноносной программой. После этого хакер сможет получить номер кредитной карточки пользователя - все из-за в корне ошибочного дизайна Вашего веб приложения. Тем не менее большинство сайтов используют cookies для предоставления различных функций, характерных для приложения.

.. _fig-bbcnews-cookies:

.. figure:: ../images/bbcnews-cookies.png
	:figclass: align-center

	Снимок экрана веб сайта BBC News (с хостингом в Великобритании) с предупреждающим сообщением об использовании cookie в верхней части страницы.

.. note:: В 2011 году, Европейский Союз (ЕС) ввел "закон о cookie" на всей территории ЕС, согласно которому все сайты с хостингом в ЕС должны выдавать предупреждающее сообщением об использовании cookie, когда пользователь посещает сайт первый раз. На Рисунке :num:`fig-bbcnews-cookies` показано такое предупреждающее сообщение для сайта BBC News. Прочитать `о законе можно здесь <http://www.ico.org.uk/for_organisations/privacy_and_electronic_communications/the_guide/cookies>`_.

.. _model-cookies-protocols-label:

Сессии и протокол без сохранения состояния
------------------------------------------
Все взаимодействия между веб браузерами (клиентами) и серверами осуществляется с помощью `HTTP протокола <http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol>`_. Как мы *уже упомянули* в Главе :ref:`forms-label`, HTTP - это `протокол без сохранения состояния <http://en.wikipedia.org/wiki/Stateless_protocol>`_. Это означает, что компьютер клиента, на котором работает веб браузер должен установить новое сетевое соединение (TCP соединение) с сервером каждый раз при запросе ресурса (HTTP ``GET``) или отправке (HTTP ``POST``) [#stateless_http11]_.

Без постоянной связи между клиентом и сервером программное обеспечение на обеих сторонах не может использовать саму связь для *хранения состояния сеанса*. Например, клиент должен передавать серверу каждый раз кто вошел в веб приложение на конкретном компьютере. Это вид *диалога* между клиентом и сервером и он является основой для *сессии* - `полупостоянного обмена информацией <http://en.wikipedia.org/wiki/Session_(computer_science)>`_. Являясь протоколом без сохранения состояния, HTTP сильно усложняет хранение состояния сессии - но, к счастью, существует несколько методов, которые можно использовать для решения этой проблемы.

Чаще всего для хранения состояния используется *идентификатор сессии*, хранящийся в виде cookie на компьютере клиента. Идентификатор сессии можно считать токеном (последовательностью символов), который используется для определения отдельной сессии в рамках конкретного веб приложения. Вместо хранения различной информации в виде cookies на стороне клиента (например, имя пользователя, личные данные, пароли...), хранится только идентификатор сессии, который затем сопоставляется структуре данных на веб сервере. В этой структуре данных, Вы можете хранить любую информацию, которая Вам требуется. Этот метод *гораздо более безопасный* способ хранения информации о пользователях. Таким образом, информацию нельзя получить взломав незащищенный клиент или отслеживая линию связи.

Если Ваш браузер поддерживает cookies почти все веб сайты создают новую сессию, когда Вы их посещаете. В этом можно убедиться, посмотрев на Рисунок :num:`fig-session-id`. В инструментах разработчика Google Chrome Вы можете просмотреть cookies, которые посылаются веб серверу. На Рисунке :num:`fig-session-id` видно ``sessionid`` (идентификатор сессии) выбранного cookie). Cookie состоит из последовательности букв и цифр, которые используются Django для однозначного определения Вашей сессии. Используя его можно получить доступ ко всем Вашим данным сессии - но только на стороне сервера. 

.. _fig-session-id:

.. figure:: ../images/session-id.png
	:figclass: align-center

	Снимок экрана Google Chrome с открытым инструментом разработчика - посмотрите на cookie ``sessionid``...

Идентификатор сессии не обязательно хранить в виде cookies. Старые PHP приложения обычно добавляли их в *строку запроса* или в URL заданного ресурса. Если Вы когда-нибудь сталкивались с URL вида ``http://www.site.com/index.php?sessid=omgPhPwtfIsThisIdDoingHere332i942394``, то вероятно таким образом сервер однозначно идентифицировал Вас. Интересно, не правда ли?

.. note:: Внимательно посмотрите на Рисунок :num:`fig-session-id`. Заметили токен ``csrftoken``? Этот cookie помогает предотвращать межсайтовую подделку запроса.

Настройка сессий в Django
-------------------------
Хотя все должно быть настроено и работать правильно, тем не менее полезно изучить такие функции выполняет каждый модуль Django. В случае сессий, Django предоставляет `ПО промежуточного уровня https://docs.djangoproject.com/en/1.7/topics/http/middleware/>`_, которое реализует функционал сессий.

Чтобы проверить, что все работает правильно, откройте файл ``settings.py`` проекта Django. В файле найдите кортеж ``MIDDLEWARE_CLASSES``. В нём должен находится модуль ``django.contrib.sessions.middleware.SessionMiddleware`` в виде строки в кортеже - если его нет, то добавьте его. Именно ``SessionMiddleware`` позволяет создавать уникальные ``sessionid`` cookies.

``SessionMiddleware`` создано таким образом, что позволяет хранить информацию о сессии различным образом. Существует множество методов, которые можно использовать - Вы можете хранить всё в файле, в базе данных или даже в кэше. Самый простой способ - это использовать приложение ``django.contrib.sessions`` для хранения информации о сессии в модели/базе данных Django (например, модели ``django.contrib.sessions.models.Session``). Для этого нужно добавить ``django.contrib.sessions`` в кортеж ``INSTALLED_APPS`` в файл ``settings.py`` Вашего приложения. Если Вы добавили его только что, необходимо обновить базу данных с помощью команд миграции.


.. note:: Если Вам нужно сверхбыстрая работа приложения, можно попробовать использовать кэш для хранения информации о сессии. Прочитайте `официальную Django документацию, связанную с кэшированием сессий <https://docs.djangoproject.com/en/1.7/topics/http/sessions/#using-cached-sessions>`_.


Использование сессий с cookie
-----------------------------
Теперь мы можем проверить поддерживает ли Ваш браузер cookies. Хотя большинство современных браузеров поддерживают cookies, стоит проверять настройки Вашего браузера, связанные с cookies. Если у Вашего браузера установлен высокий уровень безопасности, то определенные cookies могут быть заблокированы. Используя справочное руководство для Вашего браузера, включите cookies.

Проверка функционала cookie
...........................
Для проверки cookies, Вы можете использовать несколько удобных методов, предоставляемых объектом Django ``request``. Особый интерес для нас представляют три метода - это  ``set_test_cookie()``, ``test_cookie_worked()`` и ``delete_test_cookie()``. В одном представлении Вам нужно будет установить cookie. В другом - проверить, что cookie существует. Для тестирования cookies нужно два разных представления, поскольку необходимо подождать пока, клиент получит cookie от сервера.

Мы будем использовать два существующих представления для этой простой проверки: ``index()`` и ``register()``. Убедитесь, что Вы вышли из системы Rango, если Вы реализовывали функции аутентификации пользователя. Вместо вывода каких-либо сообщений на страницах, мы будем использовать терминал, в котором запускается Django сервер для разработки, чтобы проверить правильно ли работают cookies. После того как мы убедимся, что cookies действительно работают, мы можем удалить код, который мы добавили, чтобы вернуть представления в их первоначальное состояние.

В файле ``views.py`` найдите Ваше представление ``index()``. Добавьте следующую строку в представление. Чтобы строка действительно выполнялась, убедитесь, что она находится в первой строке представления, вне любых условных блоков.

.. code-block:: python
	
	request.session.set_test_cookie()

В представлении ``register()``  добавьте следующие три строки в самом начале функции - опять, чтобы гарантировать, что они точно выполнятся.

.. code-block:: python
	
	if request.session.test_cookie_worked():
	    print ">>>> TEST COOKIE WORKED!"
	    request.session.delete_test_cookie()

Сохранив эти изменения, запустите Django сервер для разработки и перейдите на главную страницу Rango ``http://127.0.0.1:8000/rango/``. Как только страница загрузиться, перейдите на страницу регистрации. После её загрузки, Вы должны увидеть ``>>>> TEST COOKIE WORKED!`` в консоли Django сервера для разработки, как показано на Рисунке :num:`fig-test-cookie`. В этом случае всё работает как надо!

.. _fig-test-cookie:

.. figure:: ../images/test-cookie.png
	:figclass: align-center

	Снимок экрана консоли Django сервера для разработки с сообщением ``>>>> TEST COOKIE WORKED!``.

Если сообщение не выводится, проверьте настройки безопасности Вашего браузера. Настройки могут запрещать браузеру принимать cookie.

.. note:: Вы можете удалить код, который добавили в этом разделе - он нужен только для демонстрации работы cookies.

Пример использования cookies на стороне клиента: счетчик количества посещений сайта
-----------------------------------------------------------------------------------
Убедившись, что cookies работают, давайте реализуем очень простой счетчик посещений сайта. Для этого мы создадим два cookies: один для подсчета количества посещений пользователем сайта Rango и второй для хранения времени последнего посещения сайта. Хранение даты и времени последнего посещения позволит нам увеличивать счетчик, например, раз в день.

Будем считать, что пользователь посещает сайт Rango, когда заходит на главную страницу. Откройте файл ``rango/views.py`` и отредактируйте представление ``index()`` следующим образом:

.. code-block:: python
	
	def index(request):
	   
	    category_list = Category.objects.all()
	    page_list = Page.objects.order_by('-views')[:5]
    	    context_dict = {'categories': category_list, 'pages': page_list}

	    # Получаем количество посещений сайта.
	    # Мы используем функцию COOKIES.get(), чтобы получить cookie с количеством посещений.
	    # Если cookie существует, exists, возвращаемое значение преобразуется в целое число.
	    # Если cookie не существует, по умолчанию значение преобразуется в нуль.
	    visits = int(request.COOKIES.get('visits', '1'))
	    
	    reset_last_visit_time = False
	    response = render(request, 'rango/index.html', context_dict)
	    # Существует ли cookie last_visit?
	    if 'last_visit' in request.COOKIES:
	        # Да существует! Получить его значение.
	        last_visit = request.COOKIES['last_visit']
	        # Преобразовать значение в Python объект дата/время.
	        last_visit_time = datetime.strptime(last_visit[:-7], "%Y-%m-%d %H:%M:%S")
	
	        # Прошло больше суток с момента последнего посещения...
	        if (datetime.now() - last_visit_time).days > 0:
	            visits = visits + 1
	            # ...поэтому обновляем флаг, отвечающий за время последнего посещения
		    reset_last_visit_time = True
	    else:
	        # Cookie last_visit не существует, поэтому создадим флаг.
	        reset_last_visit_time = True
	
		context_dict['visits'] = visits
		
	        # Получаем объект Response, чтобы можно было добавить в него информацию о cookie.
		response = render(request, 'rango/index.html', context_dict)

	    if reset_last_visit_time:
		response.set_cookie('last_visit', datetime.now())
		response.set_cookie('visits', visits)
	
	    # Возвращаем ответ пользователю, обновляя любые изменившиеся cookies.
	    return response
	    
Просматривая код, Вы увидите, что большая часть кода нужна для проверки текущей даты и времени. Для этого Вам нужно добавить Python модуль ``datetime``, используя следующий оператор импорта в начале файла ``views.py``.

.. code-block:: python
	
	from datetime import datetime

Убедитесь также, что Вы импортировали объект ``datetime`` из модуля ``datetime``.

В добавленном коде мы проверяем существует ли cookie ``last_visit``. Если да - мы извлекаем значение cookie, используя синтаксис ``request.COOKIES['cookie_name']``, где ``request`` - это название объекта ``request`` и ``'cookie_name'`` - это имя cookie, которое Вы хотите получить. **ОБратите внимание, что все значения cookie возвращаются в виде строк**; *даже, если cookie содержит только цифры, вернется не число, а строка*. Вы должны вручную преобразовать результат в правильный тип. Если cookie не существует, Вы можете создать его с помощью метода ``set_cookie()`` объекта ``response``. Метод принимает два значения: название cookie, которое нужно создать (в виде строки) и значение cookie. В этом случае, не важно какой тип Вы передаёте для значения - он будет автоматически преобразован в строку.

.. _fig-cookie-visits:

.. figure:: ../images/cookie-visits.png
	:figclass: align-center

	Снимок экрана Google Chrome с открытымы инструментами разработчика, показывающий cookies для Rango. Обратите внимание на cookie ``visits`` - пользователь в общей сложности посетил сайт шесть раз, с интервалом по крайней мере в один день.

Теперь, если Вы посетите главную страницу Rango и откроете инструменты разработчика Вашего браузера, Вы должны увидеть cookies ``visits`` и ``last_visit``. На рисунке :num:`fig-cookie-visits` показаны эти cookies.

.. note:: Может Вы заметили, что cookie ``visits`` не инкрементируется, когжа Вы обновляете Ваш веб браузер. Почему? Код, который приведен выше, увеличивает счетчик на единицу *минимум через сутки*, когда пользователь вновь посетит главную страницу Rango. Для тестирования приложения столько ждать глупо, поэтому почему бы временно не уменьшить период времени, необходимый для инкремента счетчика? В обновленном представлении ``index``, найдите следующую строку.

	``if (datetime.now() - last_visit_time).days > 0:``
	
	Мы можем легко изменить эту строку, сравнивая число *секунд* между посещениями. В приведенном ниже примере, мы сравниваем -посетил ли пользователь сайт хотя бы пятью секундами ранее.

	``if (datetime.now() - last_visit_time).seconds > 5:``
	
	Таким образом, нужно подождать только 5 секунд, чтобы увидеть, что Ваш cookie ``visits`` увеличился на единицу, а не целый день. Когда Вы убедитесь, что Ваш код работает, Вы можете вернуть первоначальное значение сравнения интервалом в один день.

	Возможность вычислять разницу во времени, используя оператор ``-`` одна из многих удивительных особенностей, которые предоставляет Python. Когда вычитаются моменты времени, возвращается объект ``timedelta``, который содержит атрибуты ``days`` и ``seconds``, используемые в вышеприведенных фрагментах кода. Вы можете просмотреть `официальную Python документацию <http://docs.python.org/2/library/datetime.html#timedelta-objects>`_, чтобы узнать больше об этом типе объектов и о том какие другие атрибуты он имеет.

Вместо использования инструментов разработчика, Вы можете обновить ``index.html`` и добавить ``<p> visits: {{ visits }}</p>``, чтобы увидеть число посещений.

Данные сессии
-------------
В предыдущем примере мы использовали cookies на стороне клиента. Но безопаснее хранить информацию о сессии на стороне сервера. Тогда мы можем использовать cookie идентификатора сессии, который хранится на стороне клиента (но не предоставляет какой-либо информации), чтобы получить эти данные.

Чтобы использовать сессии, на основе cookies, необходимо осуществить следующие шаги.

#. Удостовериться, что ``MIDDLEWARE_CLASSES`` в ``settings.py`` содержит ``django.contrib.sessions.middleware.SessionMiddleware``. 
#. Настроить бекенд Вашей сесссии. Убедитесь, что ``django.contrib.sessions`` находится в ``INSTALLED_APPS`` файла ``settings.py``. Если нет - добавить его и выполните команду миграции базы данныых - ``python manage.py migrate``.
#. По умолчанию, бекендом является база данных, но Вы можете выбрать другой (например, кэш). Смотри `официальную Django документацию по сесссиям для других конфигураций бекендов <https://docs.djangoproject.com/en/1.7/topics/http/sessions/>`_.

Теперь вместо хранения непосредственно cookies в запросе (и таким образом на машине клиента), мы можете получить доступ к cookies на стороне сервера, используя метод ``request.session.get()`` и сохранив их с помощью ``request.session[]``. Обратите внимание, что cookie идентификатора сессии используется для идентификации машины клиента (поэтому технически cookie на стороне браузера существует), но все данные хранятся на серверной стороне. Ниже мы изменили функцию ``index()``, используя сессии, на основе cookies:

.. code-block:: python
	
	def index(request):
	    
	    category_list = Category.objects.order_by('-likes')[:5]
	    page_list = Page.objects.order_by('-views')[:5]

	    context_dict = {'categories': category_list, 'pages': page_list}

	    visits = request.session.get('visits')
	    if not visits:
		visits = 1
	    reset_last_visit_time = False

	    last_visit = request.session.get('last_visit')
	    if last_visit:
	        last_visit_time = datetime.strptime(last_visit[:-7], "%Y-%m-%d %H:%M:%S")
	        
	        if (datetime.now() - last_visit_time).seconds > 0:
	            # ...прибавляем единицу к предыдущему значению cookie...
	            visits = visits + 1
	            # ...и обновляем cookie last visit cookie.
	            reset_last_visit_time = True
	    else:
	        # Cookie last_visit не существует, поэтому создаём его для текущей даты/времени.
	        reset_last_visit_time = True

	    if reset_last_visit_time:
		request.session['last_visit'] = str(datetime.now())
		request.session['visits'] = visits
	    context_dict['visits'] = visits
		

	    response = render(request,'rango/index.html', context_dict)

	    return response
	


.. warning:: Настоятельно рекомендуется удалять любые cookies на стороне клиента для Rango *перед* тем как использовать данные, на основе сессий. Это можно сделать через инструменты разработчика Вашего браузера, удалив каждый cookie по отдельности или просто очистить вешь кэш Вашего браузера и убедиться, что все cookies были удалены.

.. note:: Дополнительным преимуществом хранения данных сессии на стороне сервера является возможность преобразовывать данные из строк в любой требуемый тип. Но эта возможность работает только для встроенных типов <http://docs.python.org/2/library/stdtypes.html>`_, таких как ``int``, ``float``, ``long``, ``complex`` и ``boolean``. Если вы хотите сохранить словарь или другой сложный тип, то этот способ не сработает. В этом случае можно `сохранять/загружать объекты с помощью модуля Pickle <https://wiki.python.org/moin/UsingPickle>`_.

Браузерные и постоянные сессии
------------------------------
Используя Django фреймворк сессий можно настроить cookies для работы с *браузерными сессиями* или *постоянными сессиями*. Как следует из названий:

* браузерные сессии заканчиваются, когда пользователь закрывает свой браузер; а
* постоянные сессии могут длиться на протяжении нескольких сеансов работы с браузером - истекая в момента времени, выбранный Вами. Этот момент может настать через полчаса или даже через месяц.

По умолчанию, браузерные сессии отключены. Вы можете включить их, изменив файл ``settings.py`` Вашего Django проекта. Добавьте переменную ``SESSION_EXPIRE_AT_BROWSER_CLOSE`` и присвойте ей значение ``True``.

В противном случае, по молчанию включены постоянные сессии - если ``SESSION_EXPIRE_AT_BROWSER_CLOSE`` присвоено значение ``False`` или оно вообще не определено в файле ``settings.py`` Вашего проекта. Постоянные сессии имеют дополнительную настройку ``SESSION_COOKIE_AGE``, которая позволяет определить срок существования cookie. Значение должно быть целым числом, представляющим число секунд существования cookie. например, если указать в качестве значения ``1209600``, то это будет означать, что cookies для Вашего веб сайта истечет через две недели.

Чтобы узнать больше о доступных параметрах, которые Вы можете использовать, обратитесь к `официальной Django документации по cookies <https://docs.djangoproject.com/en/1.7/ref/settings/#session-cookie-age>`_. Также можете просмотреть `блог Eli Bendersky <http://eli.thegreenplace.net/2011/06/24/django-sessions-part-i-cookies/>`_, который является прекрасным учебным пособием по cookies и Django.

Очищаем базу данных сессий
--------------------------
Cookies сессий накапливаются, поэтому если Вы используете в качестве бекэнда базу данных, необходимо периодически очищать её. Это можно сделать с помощью команды ``python manage.py clearsessions``. В Django документации предлагается запускать её ежедневно по расписанию. Смотри https://docs.djangoproject.com/en/1.7/topics/http/sessions/#clearing-the-session-store.

Выводы и основная последовательность действий 
---------------------------------------------
При использовании cookies в Вашем Django приложении, необходимо учитывать, что:

* Во-первых, какой тип cookies необходим для Вашего веб приложения. Должна ли информация храниться на протяжении нескольких сеансов работы пользователя с браузером или её можно удалить после завершения одного сеанса?
* Тщательно продумайте какую информацию Вы хотите хранить, используя cookies. Помните, что, сохраняя информацию в cookies, Вы храните её на компьютерах клиентов. Это потенциально огромный риск в плане безопасности: нельзя гарантировать, что компьютер пользователя не взломан. Рассмотрите альтернативы с хранением информации на стороне сервера, если нужно хранить конфиденциальную информацию.
* С учетом предыдущего замечания, помните, что пользователи могут выставить высокий уровень безопасности в своих браузерах, что потенциально может заблокировать Ваши cookies. Из-за этого Ваш сайт может работать не корректно. Вы *должны* предусмотреть этот вариант, поскольку *не можете изменить настройки браузера клиента*.

Если можно использовать cookies на стороне клиента, то осуществите следующие шаги:

#. Проверьте существует ли cookie, который Вам нужен. Для этого проверьте параметр ``request``. Функция ``request.COOKIES.has_key('<название_cookie>')`` возвращает логическое значение, указывающее существует ли cookie с именем <название_cookie> на компьютере клиента или нет.
#. Если cookie существует, то Вы можете получить его значение опять с помощью параметра ``request``: ``request.COOKIES[]``. Атрибут ``COOKIES`` является словарем, поэтому внутри квадратных скобок нужно ввести название cookie, который Вы хотите получить в виде строки. Помните, что cookies всегда возвращаются в виде строк, не зависимо от того, что они содержат. Таким образом, возможно нужно будет осуществить преобразование типов.
#. Если cookie не существует или Вы хотите обновить cookie, передайте значение, которое нужно сохранить объекту ``response``. Необходимо вызвать функцию ``response.set_cookie('<название_cookie>', value)``, передав два параметра: название cookie и ``значение``, которое должно хранится в нём.

Для повышения безопасности, используйте сессии, основанные на cookies:

#. Убедитесь, что кортеж ``MIDDLEWARE_CLASSES`` в файле ``settings.py`` содержит 'django.contrib.sessions.middleware.SessionMiddleware'. 
#. Настройте бекэнд для Ваших сессий - ``SESSION_ENGINE``. О различных конфигурациях бекэнда можно прочитать в `официальной Django документации по сессиям <https://docs.djangoproject.com/en/1.7/topics/http/sessions/>`_. 
#. Проверьте существуют ли cookie с помощью функции ``requests.sessions.get()``.
#. Обновите или установите cookie с помощью словаря сессии ``requests.session['<название_cookie>']``.

Упражнения
----------
После того как Вы прочитали эту главу и поработали с кодом, выполните следующие упражнения.

- Проверьте, что Вы используете cookies на стороне сервера. Очистите кэш браузера и cookies, затем проверьте, что в браузере отсутствуют переменные ``last_visit`` и ``visits``. Заметьте, что все равно будет существовать cookie ``sessionid`` cookie. Django использует этот cookie для поиска сессии в базе данных, где хранятся все серверные cookies, связанные с этой сессией.
- Обновите представление для страницы *About* и шаблон, сообщая пользователям, сколько раз они посетили сайт.

Подсказки к упражнениям
.......................
Чтобы помочь Вам выполнить вышеприведенные упражнения, воспользуйтесь следующей подсказкой.

Передайте значение cookie в контекст шаблона, чтобы его можно было вставить в страницу, как показано в приведенном ниже примере.

.. code-block:: python
	
	# Если существует переменная сессии visits, то считать и использовать её.
	# Если нет, то пользователь не посещало сайт, поэтому присваиваем ей нулевое значение.
	if request.session.get('visits'):
	    count = request.session.get('visits')
	else:
	    count = 0

	# не забываем добавить переменную visit в словарь контекста шаблона
	return render(request, 'rango/about.html', {'visits': count})

.. rubric:: Footnotes

.. [#stateless_http11] Последняя версия HTTP стандарта HTTP 1.1 на самом деле поддерживает возможность посылки множественных запросов через одно TCP сетевое соединение. Это приводит к значительным улучшениям в производительности, особенно для сетевых соединений с большой задержкой (например, с помощью обычных телефонных модемов и спутников). Это называется *HTTP pipelining* (конвейерная обработка HTTP), о которой можно узнать, прочитав `Википедию <http://en.wikipedia.org/wiki/HTTP_pipelining>`_.

