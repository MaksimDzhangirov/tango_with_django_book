.. _login-label:

Аутентификация пользователя
===========================
Цель следующей части учебного пособия познакомить Вас с механизмами аутентификации пользователя, предоставляемые Django. Мы будем использовать приложение ``auth``, которое является часть стандартной установки Django, из пакета ``django.contrib.auth``.В соответствии с `официальной Django документацией по аутентификации <https://docs.djangoproject.com/en/1.7/topics/auth/>`_, приложение состоит из следующих частей:

- *Пользователи.*
- *Права доступа:* набор двоичных флагов (вместо слов да/нет), определяющих что пользователь может делать, а что нет.
- *Группы:* способ назначить права доступа сразу нескольким пользователям.
- Настраиваемая *система хеширования паролей:* неотъемлемая часть системы для обеспечения безопасности данных.
- *Формы и представления для входа пользователей в систему,* или ограничивающие доступ к содержимому сайта.

Многое Django может сделать за Вас при аутентификации пользователя. Мы рассмотрим основы, чтобы Вам было с чего начать изучение. Это поможет Вам уверенно работать с доступными инструментами и лежащими в их основе понятиями.

Настройка аутентификации
------------------------
Перед тем как начать работать с приложением аутентификации Django, необходимо проверить настройки в файле ``settings.py`` Вашего Rango проекта. 

В файле ``settings.py`` найдите кортеж ``INSTALLED_APPS`` и проверьте, что ``django.contrib.auth`` и ``django.contrib.contenttypes`` находятся внутри него так, что он выглядит примерно, как показано ниже:

.. code-block:: python
	
	INSTALLED_APPS = (
	    'django.contrib.admin',
	    'django.contrib.auth',
	    'django.contrib.contenttypes',
	    'django.contrib.sessions',
	    'django.contrib.messages',
	    'django.contrib.staticfiles',
	    'rango',
	)

В то время как ``django.contrib.auth`` обеспечивает Django доступ к системе аутентификации, ``django.contrib.contenttypes`` используется приложением аутентификации для отслеживания моделей, установленных в Вашей базе данных.

.. note:: Помните, если Вы добавили приложение ``auth`` в Ваш кортеж ``INSTALLED_APPS``, Вам необходимо обновить Вашу базу данных с помощью команды ``$ python manage.py migrate``.

Пароли, хранящиеся в Django, по умолчанию используют `PBKDF2 алгоритм <http://en.wikipedia.org/wiki/PBKDF2>`_, который обеспечивает хороший уровень защиты данных Ваших пользователей. Чтобы узнать больше об этом, прочитайте `официальную Django документацию о том как Django хранит пароли <https://docs.djangoproject.com/en/1.7/topics/auth/passwords/#how-django-stores-passwords>`_. В документации также объясняется как использовать различные хэши паролей, если Вам требуется ещё более высокий уровень безопасности.

Если Вы хотите ещё больше контролировать то, как хэшируются пароли, то в файл ``settings.py`` добавьте кортеж ``PASSWORD_HASHERS``:

.. code-block:: python


	PASSWORD_HASHERS = (
    	'django.contrib.auth.hashers.PBKDF2PasswordHasher',
    	'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
	)

Django будет использовать первый алгоритм хэширования в ``PASSWORD_HASHERS``, т. е., settings.PASSWORD_HASHERS[0]. Если Вы хотите использовать более безопасный алгоритм хэширования, вы можете установить Bcrypt (see https://pypi.python.org/pypi/bcrypt/ ), используя ``pip install bcrypt``, и затем модифицировать ``PASSWORD_HASHERS`` следующим образом:

.. code-block:: python


	PASSWORD_HASHERS = (
		'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
    	'django.contrib.auth.hashers.BCryptPasswordHasher',
    	'django.contrib.auth.hashers.PBKDF2PasswordHasher',
    	'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
	)
	
Однако для работы приложения аутентификации, не обязательно явно определять ``PASSWORD_HASHERS``. В этом случае Django по умолчанию использует ``django.contrib.auth.hashers.PBKDF2PasswordHasher``.

Модель ``User``
---------------
Ядро системы аутентификации Django - это объект ``User``, расположенный в ``django.contrib.auth.models.User``. Объект ``User`` представляет каждого человека, взаимодействующего с приложением Django. В `Django документации по объекту User <https://docs.djangoproject.com/en/1.7/topics/auth/default/#user-objects>`_ утверждается, что они используются, чтобы реализовать такие функции системы аутентификации как ограничение прав доступа, регистрация новых пользователей и связь содержимого сайта с его автором.

Модель ``User`` содержит пять основных атрибутов. Это:

- имя пользователя для учетной записи пользователя;
- пароль учетной записи;
- адрес электронной почты пользователя;
- имя пользователя; и
- фамилия пользователя.

Модель также имеет другие атрибуты, такие как ``is_active`` (который определяет является ли определенная учетная запись активной или нет). Прочитайте `официальную Django документацию по модели пользователя <https://docs.djangoproject.com/en/1.7/ref/contrib/auth/#django.contrib.auth.models.User>`_, чтобы узнать полный список атрибутов, предоставляемый базовой моделью ``User``.

Дополнительные атрибуты пользователя
------------------------------------
Если Вы хотите добавить другие атрибуты, отличающиеся от тех, которые уже предусмотрены в модели ``User``, то существует две возможности: (1) расширить модель ``User``, создав новую модель пользователя из ``AbstractUser`` (смотри `официальный Django документ по расширению пользователя по умолчанию Django `_<https://docs.djangoproject.com/en/1.7/topics/auth/customizing/#extending-django-s-default-user>) или (2) создать модель со связью один-к-одному с моделью ``User``. В этом учебном пособии мы будем создавать связанную модель. Для нашего приложения Rango, мы хотим добавить два дополнительных атрибута для каждой учетной записи пользователя. В частности, мы хотим добавить:

- ``URLField``, позволяет пользователю Rango указать свой собственный веб сайт; и
- ``ImageField``, позволяет пользователям задать изображения для своего профиля пользователя.

Для этого создадим дополнительную модель в файле ``models.py`` Rango. Давайте добавим новую модель под названием ``UserProfile``:

.. code-block:: python
	
	class UserProfile(models.Model):
	    # Эта строка обязательна. Она связывает UserProfile с экземпляром модели User.
	    user = models.OneToOneField(User)
	    
	    # Дополнительные атрибуты, которые мы хотим добавить.
	    website = models.URLField(blank=True)
	    picture = models.ImageField(upload_to='profile_images', blank=True)
	    
	    # Переопределяем метод __unicode__(), чтобы вернуть что-либо значимое! Используйте __str__() в Python 3.*
	    def __unicode__(self):
	        return self.user.username

Обратите внимание, что мы ссылаемся на модель ``User``, используя связь один-к-одному. Поскольку мы ссылаемся на модель по умолчанию ``User``, нам необходимо импортировать её в файл ``models.py``:

.. code-block:: python
	
	from django.contrib.auth.models import User
	
Кажется заманчивым добавить эти дополнительные поля путем непосредственного наследования модели ``User``. Однако, поскольку другим приложениям может также понадобиться доступ к модели ``User``, не рекомендуется использовать наследование, а вместо него применять связь один-к-одному.

Для Rango мы добавили два поля, чтобы дополняющие наш профиль пользователя и сдедали так, чтобы метод ``__unicode__()`` возвращал имя пользователя, когда запрашивается представление в виде Юникода экземпляра модели ``UserProfile``.

Для двух полей ``website`` и ``picture`` мы использовали атрибут ``blank`` со значением ``True``. Это значит, что каждое из этих полей может быть пустым, если необходимо, т. е., пользователи могут не ввести значения для атрибутов, если не захотят.

Обратите внимание, что поле ``ImageField`` имеет атрибут ``upload_to``. Значение этого атрибута связано с переменной проекта ``MEDIA_ROOT`` и определяет путь, где будут храниться загруженные изображения для профиля. Например, если ``MEDIA_ROOT`` равнен  ``<рабочее пространство>/tango_with_django_project/media/`, а атрибут ``upload_to`` - ``profile_images``, то все изображения профилей будут храниться в каталоге ``<рабочее пространство>/tango_with_django_project/media/profile_images/``.


.. warning:: Django поле ``ImageField`` использует *Python Imaging Library (PIL)* (библиотеку для работы с растровой графикой). В главе :ref:`requirements-label` мы рассматривали установку PIL наряду с Django. Если Вы не установили PIL, Вам необходимо это сделать сейчас. Если не сделать этого, возникнет исключение, связанное с тем, что модуль ``pil`` не был найден!

После определения модели ``UserProfile``, теперь отредактируем файл Rango ``admin.py``, добавив в него новую модель ``UserProfile`` в веб интерфейс администратора Django. В файл ``admin.py`` добавьте следующую строку.

.. code-block:: python

	from rango.models import UserProfile
	
	admin.site.register(UserProfile)


.. note:: Помните, что Вашу базу данных необходимо обновить при создании новой модели. Запустите ``$ python manage.py makemigrations rango`` из Вашего терминала, чтобы создать скрипты для миграции новой модели ``UserProfile``. Затем выполните ``$ python manage.py migrate``.

Создание представления и шаблона *User Registration*
----------------------------------------------------
После того как спроектирована инфраструктура аутентификации, можно начать генерировать её, предоставляя пользователям нашего приложения возможность создавать новые пользовательские учетные записи. Мы добьемся этого путем создания комбинации из нового представления и шаблона.

.. note:: Важно отметить, что доступно несколько стандартных пакетов для регистрации пользователей, которые упрощают множество задач, связанных с созданием своих собственных форм для регистрации и входа. Тем не менее, хорошо получить некоторое представление о механике, используемых приложений. Это также позволит закрепить Ваши знания по работе с формами, как расширить модель пользователя и как загрузить медиа файлы.

Чтобы реализовать функцию регистрации пользователя, необходимо выполнить следующие шаги:

#. Создать ``UserForm`` и ``UserProfileForm``.
#. Добавить представление для обработки данных при создании нового пользователя.
#. Создать шаблон, который отображает ``UserForm`` и ``UserProfileForm``.
#. Сопоставить URL созданному представлению.
#. Создать ссылку на страницу регистрации на главной странице


.. _login-formclasses-label:

Создание ``UserForm`` и ``UserProfileForm``
.................................................
Теперь в ``rango/forms.py`` нам нужно создать два класса, которые наследуются от ``forms.ModelForm``. Мы создадим один для базового класса ``User`` и второй для новой модели ``UserProfile``, которую мы только что создали. Два класса, наследующихся от ``ModelForm``, позволят отображать HTML форму с необходимыми полями для конкретной модели, выполняя значительную часть работы за нас. Здорово!

Давайте создадим наши два класса в ``rango/forms.py``, которые наследуются от ``forms.ModelForm``. Добавьте следующий код в модуль.

.. code-block:: python
	
	class UserForm(forms.ModelForm):
	    password = forms.CharField(widget=forms.PasswordInput())
	    
	    class Meta:
	        model = User
	        fields = ('username', 'email', 'password')

	class UserProfileForm(forms.ModelForm):
	    class Meta:
	        model = UserProfile
	        fields = ('website', 'picture')

Заметьте, что в оба класса мы добавили `вложенный <http://www.brpreiss.com/books/opus7/html/page598.html>`_ ``Meta`` класс. Как `предполагает название вложенного класса <http://www.webopedia.com/TERM/M/meta.html>`_, все что находится внутри вложенного класса ``Meta`` описывает дополнительные свойства, касающиеся конкретного класса ``ModelForm``, которому он принадлежит. Каждый класс ``Meta`` должен как минимум иметь поле ``model``, которое ссылается на модель, на основе которой создается форма, наследуемая от класса ``ModelForm``. Таким образом, наш класс ``UserForm`` связан с моделью ``User``. Для Django 1.7 Вы также должны определить поля ``fields`` или исключить поля ``exclude``, чтобы указать какие поля, связанные с моделью, должны быть представлены в форме.

Здесь мы хотим отображать поля ``username``, ``email`` и ``password``, связанные с моделью ``User``, и ``website`` и ``picture``, связанные с моделью ``UserProfile``. Для поля ``user`` в ``UserProfile`` необходимо создать связь с моделью ``User`` при регистрации пользователя.

Заметьте также, что ``UserForm`` содержит определение атрибута ``password``. Хотя экземпляр модели ``User`` содержит атрибут ``password`` по умолчанию, выводимое поле HTML формы не будет скрывать пароль. Когда пользователь будет вводить пароль, его будет видно. Обновляя атрибут ``password`` мы можем определить, что экземпляр ``CharField`` должен скрывать введенные пользователем символы, используя виджет ``PasswordInput()``.

Наконец, не забудем включать требуемые классы в начале модуля ``forms.py``!

.. code-block:: python
	
	
	from django import forms
	from django.contrib.auth.models import User
	from rango.models import Category, Page, UserProfile

Создание представления ``register()``
.....................................
Затем необходимо вывести форму и обработать данные, введенные в неё. В файле ``views.py`` Rango добавьте следующую функцию-представление:

.. code-block:: python
	
	from rango.forms import UserForm, UserProfileForm
	
	def register(request):
	    
	    # Логическое значение указывающее шаблону прошла ли регистрация успешно.
	    # В начале ему присвоено значение False. Код изменяет значение на True, если регистрация прошла успешно.
	    registered = False
	    
	    # Если это HTTP POST, мы заинтересованы в обработке данных формы.
	    if request.method == 'POST':
	        # Попытка извлечь необработанную информацию из формы.
	        # Заметьте, что мы используем UserForm и UserProfileForm.
	        user_form = UserForm(data=request.POST)
	        profile_form = UserProfileForm(data=request.POST)
	        
	        # Если в две формы введены правильные данные...
	        if user_form.is_valid() and profile_form.is_valid():
	            # Сохранение данных формы с информацией о пользователе в базу данных.
	            user = user_form.save()
	            
	            # Теперь мы хэшируем пароль с помощью метода set_password.
	            # После хэширования мы можем обновить объект "пользователь".
	            user.set_password(user.password)
	            user.save()
	            
	            # Теперь разберемся с экземпляром UserProfile.
	            # Поскольку мы должны сами назначить атрибут пользователя, необходимо приравнять commit=False.
	            # Это отложит сохранение модели, чтобы избежать проблем целостности.
	            profile = profile_form.save(commit=False)
	            profile.user = user
	            
	            # Предоставил ли пользователь изображение для профиля?
	            # Если да, необходимо извлечь его из формы и поместить в модель UserProfile.
	            if 'picture' in request.FILES:
	                profile.picture = request.FILES['picture']
	            
	            # Теперь мы сохраним экземпляр модели UserProfile.
	            profile.save()
	            
	            # Обновляем нашу переменную, чтобы указать, что регистрация прошла успешно.
	            registered = True
	        
	        # Неправильная формы или формы - ошибки или ещё какая-нибудь проблема?
	        # Вывести проблемы в терминал.
	        # Они будут также показаны пользователю.
	        else:
	            print user_form.errors, profile_form.errors
	    
	    # Не HTTP POST запрос, следователь мы выводим нашу форму, используя два экземпляра ModelForm.
	    # Эти формы будут не заполненными и готовы к вводу данных от пользователя.
	    else:
	        user_form = UserForm()
	        profile_form = UserProfileForm()
	    
	    # Выводим шаблон в зависимости от контекста.
	    return render(request,
	            'rango/register.html',
	            {'user_form': user_form, 'profile_form': profile_form, 'registered': registered} )

Стало ли представление намного сложнее. Сначала может показаться, что да, но это не совсем так. Единственное отличие от нашего предыдущего представления ``add_category()`` заключается в необходимости обработать два отдельных экземпляра ``ModelForm`` - один для модели ``User`` и второй для модели ``UserProfile``. Нам также необходимо обработать изображение для профиля пользователя, если он или она захочет его загрузить.

Мы также установили связь между двумя экземплярами модели, которые создали. После создания нового экземпляра модели ``User`` мы сослались на него в экземпляре ``UserProfile`` в строке ``profile.user = user``. В этом месте заполняем атрибут ``user`` формы ``UserProfileForm``, который мы скрыли от пользователей в Разделе :ref:`login-formclasses-label`.

Создание шаблона *Регистрация* (Registration)
.............................................
Теперь создадим новый файл шаблона - ``rango/register.html`` и добавим следующий код:

.. code-block:: html
	
	<!DOCTYPE html>
	<html>
	    <head>
	        <title>Rango</title>
	    </head>

	    <body>
	        <h1>Register with Rango</h1>

	        {% if registered %}
	        Rango says: <strong>thank you for registering!</strong>
	        <a href="/rango/">Return to the homepage.</a><br />
	        {% else %}
	        Rango says: <strong>register here!</strong><br />

	        <form id="user_form" method="post" action="/rango/register/"
	                enctype="multipart/form-data">

	            {% csrf_token %}
	            
	            <!-- Выводим на экран каждую форму. Метод as_p помещает каждый элемент в абзац (тег <p>). Это гарантирует, что каждый элемент появится на новой строке, улучшая внешний вид формы. -->
	            {{ user_form.as_p }}
	            {{ profile_form.as_p }}
	            
	            <!-- Создаем кнопку для отправления данных формы. -->
	            <input type="submit" name="submit" value="Register" />
	        </form>
	        {% endif %}
	    </body>
	</html>

Этот HTML шаблон использует переменную ``registered``, которая применялась в нашем представлении для обозначения того прошла ли регистрация успешно или нет. Учтите, что переменная ``registered`` должна быть равна ``False``, чтобы шаблон вывел форму для регистрации - в противном случае выводится сообщение об успешной регистрации.

.. warning::
	Вы должны быть знакомы с атрибутом ``enctype`` элемента ``<form>``. Если Вы хотите позволить пользователям загружать файлы из формы, обязательным условием является присвоение ``enctype`` значения ``multipart/form-data``. Этот атрибут и его значение указывают Вашему браузеру посылать данные формы особым образом обратно на сервер. В частности, данные, представляющие Ваш файл деляется на части и отправляются. Чтобы узнать больше, прочитайте `этот хороший ответ на Stack Overflow <http://stackoverflow.com/a/4526286>`_. Вы должны также не забыть добавить CSRF токен. Убедитесь, что Вы вставили ``{% csrf_token %}`` в Ваш элемент ``<form>``

Сопоставление URL представлению ``register()``
..............................................
Теперь мы можем сопоставить URL нашему новому представлению. В ``rango/urls.py`` измените кортеж ``urlpatterns`` следующим образом:

.. code-block:: python
	
	urlpatterns = patterns('',
	    url(r'^$', views.index, name='index'),
	    url(r'^about/$', views.about, name='about'),
	    url(r'^category/(?P<category_name_slug>\w+)$', views.category, name='category'),
	    url(r'^add_category/$', views.add_category, name='add_category'),
	    url(r'^category/(?P<category_name_slug>\w+)/add_page/$', views.add_page, name='add_page'),
	    url(r'^register/$', views.register, name='register'), # ДОБАВЛЯЕМ НОВЫЙ ШАБЛОН!
	    )

Только что добавленный шаблон связывает URL ``/rango/register/`` с представлением ``register()``.

Добавляем ссылку
................
Наконец, добавим ссылку, указывающую на этот URL в наш шаблон главной страницы ``index.html``. Под ссылкой на страницу добавления категории, добавьте следующую гиперссылку.

.. code-block:: html
	
	<a href="/rango/register/">Register Here</a>

Пример работы
.............
Показать как работает приложение? Легко! Теперь у Вас есть новая гиперссылка с текстом ``Register Here``, которая перенаправляет Вас на страницу регистрации. Воспользуйтесь ей! Запустите сервер для разработки Django и попытайтесь зарегистрировать новую учетную запись пользователя. Загрузите изображение для профиля, если хотите. Ваша форма для регистрации должна выглядеть как показано на Рисунке :num:`fig-rango-register-form`.

.. _fig-rango-register-form:

.. figure:: ../images/rango-register-form.png
	:figclass: align-center

	Снимок экрана с формой для регистрации, которую Вы создадите при изучении этого учебного пособия.
	

После того как Вы увидите сообщение о том, что Вы были успешно зарегистрированы, в базе данных будут созданы две новых записи в таблицах, соответствующих моделям ``User`` и ``UserProfile``.

Добавление функции входа в систему
----------------------------------
После того как реализована возможность регистрации, теперь нам необходимо добавить функцию входа в систему. Для этого нужно выполнить следующую последовательность действий:

* Создать представление login для обработки учетных данных пользователей
* Создать шаблон login для отображения формы входа в систему
* Сопоставление представления login с URL
* Создание ссылки на форму входа в систему с главной страницы

Создание представления ``login()``
..................................
В ``rango/views.py`` создайте новую функцию под названием ``user_login()`` и добавьте следующий код:

.. code-block:: python
	
	def user_login(request):
	    
	    # Если запрос HTTP POST, пытаемся извлечь нужную информацию.
	    if request.method == 'POST':
	        # Получаем имя пользователя и пароль, вводимые пользователем.
	        # Эта информация извлекается из формы входа в систему.
			# Мы используем request.POST.get('<имя переменной>') вместо request.POST['<имя переменной>'], 
			# потому что request.POST.get('<имя переменной>') вернет None, если значения не существует, 
			# тогда как request.POST['<variable>'] создаст исключение, связанное с отсутствем значения с таким ключом
	        username = request.POST.get('username')
	        password = request.POST.get('password')
	        
	        # Используйте Django, чтобы проверить является ли правильным 
	        # сочетание имя пользователя/пароль - если да, то возвращается объект User.
	        user = authenticate(username=username, password=password)
	        
	        # Если мы получили объект User, то данные верны.
	        # Если получено None (так Python представляет отсутствие значения), то пользователь
	        # с такими учетными данными не был найден.
	        if user:
	            # Аккаунт активен? Он может быть отключен.
	            if user.is_active:
	                # Если учетные данные верны и аккаунт активен, мы можем позволить пользователю войти в систему.
	                # Мы возвращаем его обратно на главную страницу.
	                login(request, user)
	                return HttpResponseRedirect('/rango/')
	            else:
	                # Использовался не активный аккуант - запретить вход!
	                return HttpResponse("Your Rango account is disabled.")
	        else:
	            # Были введены неверные данные для входа. Из-за этого вход в систему не возможен.
	            print "Invalid login details: {0}, {1}".format(username, password)
	            return HttpResponse("Invalid login details supplied.")
	    
	    # Запрос не HTTP POST, поэтому выводим форму для входа в систему.
	    # В этом случае скорее всего использовался HTTP GET запрос.
	    else:
	        # Ни одна переменная контекста не передается в систему шаблонов, следовательно, используется
	        # объект пустого словаря...
	        return render(request, 'rango/login.html', {})

Это представление может показаться сложным, так как оно должно учитывать различные ситуации. Как и в предыдущих примерах, представление ``user_login()`` осуществляет отображение формы и её обработку.

Во-первых, если обращение к представлению осуществлялось через HTTP GET метод, то отображается форма входа в систему. Однако, если форма была передана через HTTP POST метод, то мы должны обработать форму.

Если передана форма без ошибок, то из формы извлекаются имя пользователя и пароль. Эти данные затем используются для аутентификации пользователя (с помощью функции Django ``authenticate()``). ``authenticate()`` возвращает объект ``User``, если комбинация имя пользователя/пароль существует в базе данных - или ``None``, если совпадений не было найдено.

Если мы получили объект ``User``, то мы можем проверить, является ли учетная запись активной или нет - и выполнить действия в зависимости от результата проверки.

Однако, если передана форма с ошибкой, например, пользователь не ввел имя или пароль, то опять выводится форма входу в систему с сообщениями об ошибках (например, не было введено имя пользователя/пароль).

Особый интерес в вышеприведенном примере кода представляет встроенный механизм Django, помогающий осуществлять процесс аутентификации. Обратите внимание, что функция ``authenticate()`` используется, чтобы проверить соответствуют ли введенные имя пользователя и пароль существующей учетной записи пользователя, а функция ``login()``, чтобы указать Django, что пользователь должен быть зарегистрирован в системе.

Заметьте также, что мы используем новый класс ``HttpResponseRedirect``. Как видно из имени, результат, генерируемый экземпляром класса ``HttpResponseRedirect`` указывает браузеру клиента осуществить переадресацию на URL, который Вы передаете в качестве аргумента. Учтите, что это приведет к HTTP коду статуса 302, который обозначает переадресацию, а не код состояния 200, т. е., OK. 
Чтобы узнать больше, просмотрите  `официальную Django документацию по Переадресации <https://docs.djangoproject.com/en/1.7/ref/request-response/#django.http.HttpResponseRedirect>`_.

Все эти функции и классы предоставляются Django, таким образом, Вам нужно импортировать их, поэтому добавьте следующий код для импорта в ``rango/views.py``:

.. code-block:: python
	
	from django.contrib.auth import authenticate, login
	from django.http import HttpResponseRedirect, HttpResponse

Создание шаблона *Login*
........................
После создания нашего нового представления, нам надо создать новый шаблон, который позволит пользователям войти в систему. Хотя мы знаем, что шаблон будет находиться в каталоге ``templates/rango/``, название файла Вы должны определить сами. Просмотрите вышеприведенный пример кода, чтобы найти название. В Вашем новом файле шаблона, добавьте следующий код:

.. code-block:: html
	
	<!DOCTYPE html>
	<html>
	    <head>
	        <!-- Никому не надоело каждый раз вводить заголовок??? -->
	        <title>Rango</title>
	    </head>

	    <body>
	        <h1>Login to Rango</h1>

	        <form id="login_form" method="post" action="/rango/login/">
	            {% csrf_token %}
	            Username: <input type="text" name="username" value="" size="50" />
	            <br />
	            Password: <input type="password" name="password" value="" size="50" />
	            <br />

	            <input type="submit" value="submit" />
	        </form>

	    </body>
	</html>

Убедитесь, что атрибуты ``name`` тегов *input* совпадают с названиями переменных, которые Вы определили в представлении ``user_login()`` - т. е., ``username`` для имени пользователя и ``password`` для пароля. Не забудьте также о ``{% csrf_token %}``!

Сопоставление URL представлению Login
.....................................
Создав шаблон *Login*, теперь мы можем сопоставить URL представлению ``user_login()``. Измените файл Rango ``urls.py`` так, чтобы его кортеж ``urlpatterns`` теперь выглядел как код, показанный ниже:

.. code-block:: python
	
	urlpatterns = patterns('',
	    url(r'^$', views.index, name='index'),
	    url(r'^about/$', views.about, name='about'),
	    url(r'^category/(?P<category_name_slug>\w+)$', views.category, name='category'),
	    url(r'^add_category/$', views.add_category, name='add_category'),
	    url(r'^category/(?P<category_name_slug>\w+)/add_page/$', views.add_page, name='add_page'),
	    url(r'^register/$', views.register, name='register'),
	    url(r'^login/$', views.user_login, name='login'),
	    )

Создание ссылки
...............
Наконец, для удобства пользователей Rango мы создадим ссылку для перехода на страницу входа в систему. Для этого мы отредактируем шаблон ``index.html`` в каталоге ``templates/rango/``. Найдите ранее созданные ссылки на добавление категории и страницу регистрации и добавьте следующую гиперссылку под ними. Возможно, Вы захотите добавить разрыв строки (``<br />``) перед ссылкой.

.. code-block:: python
	
	<a href="/rango/login/">Login</a>

Также вы можете изменить заголовок главной страницы, в котором будете выдавать сообщение, обращенное к пользователю, если он вошел в систему и стандартное сообщение, которое видно всем, если нет. В шаблоне ``index.html`` найдите заголовок, который показан в приведенном ниже фрагменте кода.

.. code-block:: python
	
	<h1>Rango says..hello world!</h1>

Замените этот заголовок следующей разметкой и кодом шаблона Django. Обратите внимание, что мы использовали объект ``user``, который доступен системе шаблонов Django через контекст. Мы можем узнать с помощью этого объекта: вошел ли пользователь в систему (аутентифицирован ли он). Если да, мы можем также получить информацию о нем или ней.

.. code-block:: python
	
	{% if user.is_authenticated %}
	<h1>Rango says... hello {{ user.username }}!</h1>
	{% else %}
	<h1>Rango says... hello world!</h1>
	{% endif %}

Как видно из примера, мы использовали Язык Шаблона Django, чтобы проверить аутентифицирован ли пользователь с помощью тега ``{% if user.is_authenticated %}``. Переменная контекста, которую мы передали в шаблон, содержит в себе переменную user, если пользователь вошел в систему, поэтому мы можем проверить так ли это. Если да, то он или она получит персональное приветствие в заголовке, т. е., ``Rango says... hello leifos!`` ("Ранго говорит... привет leifos! (имя пользователя)" - Прим. переводчика). В противном случае, выдается стандартный заголовок ``Rango says... hello world!`` ("Ранго говорит... привет мир!" - Прим. переводчика).

Пример работы
.............
На Рисунке :num:`fig-rango-login-message` показаны снимки экрана, показывающие как всё должно выглядеть.

.. _fig-rango-login-message:

.. figure:: ../images/rango-login-message.png
	:figclass: align-center

	Снимки экрана, показывающие заголовок, который пользователи видят, когда вход в систему не осуществлен и когда вход осуществлен с именем пользователя ``somebody``.

Теперь пользователи могут осуществлять вход в систему! Чтобы всё проверить, запустите сервер для разработки Django и попытайтесь зарегистрировать новую учетную запись. После успешной регистрации, у Вас должно получиться войти в систему, используя данные, которые Вы только что предоставили.

Ограничение доступа
-------------------
Теперь, когда пользователи могут входить в систему, мы можем ограничить доступ к определенным частям приложения в соответствии с ТЗ, т. е., чтобы только зарегистрированные пользователи могли добавлять категории и страницы. Используя Django этого можно добиться двумя способами:

* путем непосредственной обработки объекта ``request`` и проверки аутентифицирован ли пользователь или
* используя удобную функцию *декоратор*, которая проверяет аутентифицирован ли пользователь.

Первый метод проверяет вошел ли пользователь в систему, используя метод ``user.is_authenticated()``. Объект ``user`` доступен через объект ``request``, который передается представлению. Следующий пример демонстрирует этот метод.

.. code-block:: python
	
	def some_view(request):
	    if not request.user.is_authenticated():
	        return HttpResponse("You are logged in.")
	    else:
	        return HttpResponse("You are not logged in.")

Второй метод использует `Python декораторы <http://wiki.python.org/moin/PythonDecorators>`_. Декораторы получили такое название благодаря `шаблону проектирования программного обеспечения с таким же названием <http://en.wikipedia.org/wiki/Decorator_pattern>`_.  Они могут динамически изменять функциональное назначение функции, метода или класса без необходимости непосредственного редактирования этой функции, метода или класса.

В Django существует декоратор ``login_required()``, который мы можем присоединить к любому представлению, для которого требуется, чтобы пользователь вошел в систему. Если пользователь не вошел в систему и попытается получить доступ к странице, которая вызывает такое представление, то пользователь будет переадресован на другую страницу по Вашему выбору - как правило, на страницу входа в систему.

Ограничение доступа с помощью декоратора
..........................................
Применим только что полученные значения на практике, создав представление в файле ``views.py`` Rango под названием ``restricted()`` и добавив в него следующий код:

.. code-block:: python
	
	@login_required
	def restricted(request):
	    return HttpResponse("Since you're logged in, you can see this text!")

Обратите внимание, чтобы использовать декоратор, его надо поместить *непосредственно над* названием функции и поставить ``@`` перед названием декоратора. Python выполнит декоратор перед выполнением кода Вашей функции/метода. Для использования декоратора Вы должны импортировать его, поэтому добавьте следующий импорт:

.. code-block:: python
	
	from django.contrib.auth.decorators import login_required

Мы также добавим ещё один шаблон в кортеж Rango ``urlpatterns`` в файл ``urls.py``. Наш кортеж должен после этого выглядеть примерно как показано в следующем примере. Обратите внимание на последнюю строчку с представлением ``views.restricted`` - именно её необходимо добавить.

.. code-block:: python
	
	urlpatterns = patterns('',
	    url(r'^$', views.index, name='index'),
	    url(r'^add_category/$', views.add_category, name='add_category'),
	    url(r'^register/$', views.register, name='register'),
	    url(r'^login/$', views.user_login, name='login'),
	    url(r'^(?P<category_name_slug>\w+)', views.category, name='category'),
	    url(r'^restricted/', views.restricted, name='restricted'),
	    )

Также необходимо учесть случай, когда пользователь пытается получить доступ к представлению ``restricted()``, но не вошел в систему. Что нужно делать в этом случае? Самый простой вариант - переадресовать его или её браузер. Django позволяет указать это в файле ``settings.py`` нашего проекта, расположенного в каталоге конфигурации проекта. В ``settings.py`` определите переменную ``LOGIN_URL`` с URL, на который нужно перенаправить пользователей, которые не вошли в систему, т. е., на страницу входа в систему, расположенную по адресу ``/rango/login/``:

.. code-block:: python
	
	LOGIN_URL = '/rango/login/'

Это гарантирует, что декоратор ``login_required()`` переадресует любого пользователя, который не вошел в систему, на URL ``/rango/login/``.

Выход их системы
----------------
Хорошо также предоставлять пользователю возможность выхода из системы. Django имеет удобную функцию ``logout()``, которая реализует выход пользователя из системы и заканчивает сессию. После этого, последующие попытки получить доступ к представлению, приведут к отказу доступа и перенаправлению на страницу входа в систему.

Для реализации функции выхода из системы в ``rango/views.py`` добавьте представление ``user_logout()`` со следующим кодом:

.. code-block:: python
	
	from django.contrib.auth import logout
	
	# Используйте декоратор login_required(), чтобы гарантировать, что только авторизированные пользователи смогут получить доступ к этому представлению.
	@login_required
	def user_logout(request):
	    # Поскольку мы знаем, что только вошедшие в систему пользователи имеют доступ к этому представлению, можно осуществить выход из системы 
	    logout(request)
	    
	    # Перенаправляем пользователя обратно на главную страницу.
	    return HttpResponseRedirect('/rango/')


После создания представления ``user_logout()``, сопоставьте ему URL ``/rango/logout/``, изменив кортеж ``urlpatterns`` в модуле Rango ``urls.py``:

.. code-block:: python
	
	urlpatterns = patterns('',
	    url(r'^$', views.index, name='index'),
	    url(r'^about/$', views.about, name='about'),
	    url(r'^category/(?P<category_name_slug>\w+)$', views.category, name='category'),
	    url(r'^add_category/$', views.add_category, name='add_category'),
	    url(r'^category/(?P<category_name_slug>\w+)/add_page/$', views.add_page, name='add_page'),
	    url(r'^register/$', views.register, name='register'),
	    url(r'^login/$', views.user_login, name='login'),
	    url(r'^restricted/$', views.restricted, name='restricted'),
	    url(r'^logout/$', views.user_logout, name='logout'),
	    )

Теперь после реализации функция выхода пользователя из системы, создадим ссылку на главной странице, нажав которую пользователи смогут выйти из системы. Однако подумайте: необходимо ли выдавать такую ссылку пользователю, который не вошел в систему? Скорее всего нет - такому пользователю, например, можно выдать ссылку на страницу регистрации.

Как в предыдущем разделе, изменим шаблон Rango ``index.html``, и используем объект ``user`` из контекста шаблона, чтобы определить такую ссылку показывать. Найдите список со ссылками внизу страницы и замените его следующей HTML разметкой и кодом шаблона Django. Учтите, что мы также добавили ссылку на нашу страницу с ограниченным доступом ``/rango/restricted/``.

.. code-block:: html
	
	{% if user.is_authenticated %}
	<a href="/rango/restricted/">Restricted Page</a><br />
	<a href="/rango/logout/">Logout</a><br />
	{% else %}
	<a href="/rango/register/">Register Here</a><br />
	<a href="/rango/login/">Login</a><br />
	{% endif %}
	
	<a href="/rango/about/">About</a><br/>
	<a href="/rango/add_category/">Add a New Category</a><br />

Итак - когда пользователь прошел аутентификацию и вошел в систему, он или она видит ссылки ``Restricted Page`` и ``Logout``. Если он или она не вошел в систему, отображаются ссылки ``Register Here`` и ``Login``. Ссылки ``About`` и ``Add a New Category`` находятся за условными блоками, поэтому доступны как анонимным, так и авторизированным пользователям.

Упражнения
----------
Эта глава охватывает несколько важных принципов управления аутентификацией пользователя с помощью Django. Мы рассмотрели основы установки приложения Django ``django.contrib.auth`` в наш проект. Кроме того, мы также показали как реализовать модель профиля пользователя, в которой могут существовать дополнительные поля по сравнению с базовой моделью ``django.contrib.auth.models.User``. Мы также рассмотрели процесс создания функций, позволяющих осуществлять регистрацию пользователя, вход/выход в/из системы и управление доступом. Чтобы узнать больше об аутентификации пользователя и регистрации обратитесь к `официальной Django документации по аутентификации <https://docs.djangoproject.com/en/1.7/topics/auth/>`_.

* Измените приложение так, чтобы только зарегистрированные пользователи могли добавлять/редактировать, а не зарегистрированные только просматривать/использовать категории/страницы. Также убедитесь, что ссылки, позволяющие добавить/отредактировать страницы появляются, только если пользователь, просматривает веб сайт, войдя в систему.

* Предусмотрите вывод информативных сообщений об ошибках в случае, когда пользователи неправильно вводят свои имена или пароли.

В большинстве приложений требуется различный уровень безопасности при регистрации и управлении пользователями - например, как убедиться, что пользователь ввел адрес электронной почти, к которому он имеет доступ, или как послать пользователю пароль, если он его забыл. Хотя можно было расширить существующую реализацию и создать всю необходимую инфраструктуру для поддержки такого функционала, но уже разработано приложение ``django-registration-redux``, которое сильно упрощает процесс - посетите https://django-registration-redux.readthedocs.org, чтобы узнать больше о том, как использовать этот пакет. Шаблоны доступны по адресу: https://github.com/macdhuibh/django-registration-templates.


